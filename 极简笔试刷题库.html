<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åŒ»å­¦çŸ¥è¯† - æç®€æ™ºèƒ½åˆ·é¢˜åº“</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* Tailwind JIT needs this for dynamic classes sometimes */
        .knowledge-tree-level-1 {}
        .knowledge-tree-level-2 {}
        .knowledge-tree-level-3 {}
        .weakness-high {}
        .weakness-medium {}
        .weakness-low {}

        /* ä¿æŒåŸæœ‰æ ·å¼ä¸å˜ */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap');
        
        * {
            font-family: 'Inter', sans-serif;
            scroll-behavior: smooth;
        }
        
        :root {
            --primary-color: #E31937;
            --secondary-color: #FF6B6B;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --error-color: #ef4444;
            --correct-bg: #f0fdf4;
            --wrong-bg: #fef2f2;
        }
        
        .gradient-text {
            background: linear-gradient(135deg, #E31937, #FF6B6B);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        /* æµ®åŠ¨å¯¼èˆªæ ·å¼ */
        .floating-nav { 
            position: fixed; 
            left: 0; 
            top: 50%; 
            transform: translateY(-50%); 
            z-index: 1000; 
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1); 
        }
        
        .nav-trigger { 
            position: absolute; 
            left: 0; 
            top: 50%; 
            transform: translateY(-50%); 
            width: 50px; 
            height: 50px; 
            background: linear-gradient(135deg, #E31937, #FF6B6B); 
            border-radius: 0 25px 25px 0; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            cursor: pointer; 
            box-shadow: 4px 0 20px rgba(227, 25, 55, 0.3); 
            transition: all 0.3s ease; 
            z-index: 1001; 
        }
        
        .nav-trigger:hover { 
            transform: translateY(-50%) translateX(5px); 
            box-shadow: 6px 0 25px rgba(227, 25, 55, 0.4); 
        }
        
        .nav-trigger i { 
            color: white; 
            font-size: 1.2rem; 
            transition: transform 0.3s ease; 
        }
        
        .floating-nav.collapsed .nav-trigger { 
            left: 20px; 
        }
        
        .nav-panel { 
            position: absolute; 
            left: 0; 
            top: 50%; 
            transform: translateY(-50%) translateX(-100%); 
            width: 420px; 
            max-height: 90vh; 
            background: linear-gradient(180deg, #ffffff 0%, #f8fafc 100%); 
            border-radius: 0 20px 20px 0; 
            box-shadow: 8px 0 40px rgba(0, 0, 0, 0.15); 
            opacity: 0; 
            visibility: hidden; 
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1), visibility 0.4s; 
            overflow-y: auto; 
            border: 1px solid #e2e8f0; 
            border-left: none; 
        }
        
        .floating-nav.expanded .nav-panel { 
            transform: translateY(-50%) translateX(50px); 
            opacity: 1; 
            visibility: visible; 
        }
        
        .floating-nav.expanded .nav-trigger i { 
            transform: rotate(180deg); 
        }
        
        .nav-header { 
            padding: 1.25rem; 
            background: linear-gradient(135deg, #E31937, #FF6B6B); 
            color: white; 
            border-radius: 0 18px 0 0; 
        }
        
        .nav-title { 
            font-size: 1rem; 
            font-weight: 700; 
            margin-bottom: 0.3rem; 
            display: flex; 
            align-items: center; 
            gap: 0.5rem; 
        }
        
        .nav-subtitle { 
            font-size: 0.75rem; 
            opacity: 0.9; 
        }
        
        .nav-content { 
            padding: 0.75rem 0; 
        }
        
        .nav-section { 
            margin-bottom: 1rem; 
        }
        
        .nav-section-title { 
            padding: 0 1.25rem 0.5rem; 
            font-size: 0.65rem; 
            font-weight: 700; 
            text-transform: uppercase; 
            letter-spacing: 0.05em; 
            color: #64748b; 
            border-bottom: 1px solid #f1f5f9; 
            margin-bottom: 0.5rem; 
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .nav-item { 
            display: flex; 
            align-items: center; 
            padding: 0.6rem 1.25rem; 
            color: #374151; 
            text-decoration: none; 
            font-weight: 500; 
            font-size: 0.8rem; 
            transition: all 0.2s ease; 
            border-left: 3px solid transparent; 
            position: relative; 
            cursor: pointer; 
        }
        
        .nav-item:hover, .nav-item.active { 
            background: linear-gradient(90deg, rgba(227, 25, 55, 0.08) 0%, rgba(227, 25, 55, 0.02) 100%); 
            color: #E31937; 
            border-left-color: #E31937; 
        }
        
        .nav-item.active { 
            font-weight: 600; 
        }
        
        .nav-item-icon { 
            margin-right: 0.75rem; 
            font-size: 0.9rem; 
            width: 18px; 
            text-align: center; 
            color: #E31937; 
        }
        
        .nav-item-content { 
            flex: 1; 
            display: flex; 
            flex-direction: column; 
        }
        
        .nav-item-name { 
            font-weight: 600; 
            margin-bottom: 0.15rem; 
        }
        
        .nav-item-progress { 
            display: flex; 
            align-items: center; 
            gap: 0.5rem; 
            font-size: 0.65rem; 
            color: #64748b; 
        }
        
        .mini-progress-bar { 
            flex: 1; 
            height: 4px; 
            background: #e2e8f0; 
            border-radius: 2px; 
            overflow: hidden; 
        }
        
        .mini-progress-fill { 
            height: 100%; 
            background: linear-gradient(90deg, #10b981, #059669); 
            border-radius: 2px; 
            transition: width 0.3s ease; 
        }
        
        .nav-item-count { 
            font-size: 0.65rem; 
            color: #64748b; 
            white-space: nowrap; 
        }

        /* çŸ¥è¯†æ ‘å±‚çº§æ ·å¼ */
        .knowledge-tree-level {
            margin-left: 0;
        }
        
        .knowledge-tree-level-1 {
            margin-left: 0;
            background: rgba(227, 25, 55, 0.05);
        }
        
        .knowledge-tree-level-2 {
            margin-left: 1rem;
            background: rgba(227, 25, 55, 0.03);
            font-size: 0.75rem;
        }
        
        .knowledge-tree-level-3 {
            margin-left: 2rem;
            background: rgba(227, 25, 55, 0.02);
            font-size: 0.7rem;
        }

        .knowledge-tree-toggle {
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 4px;
            transition: all 0.2s ease;
            background: none;
            border: none;
            color: #64748b;
            font-size: 0.75rem;
        }

        .knowledge-tree-toggle:hover {
            background: rgba(227, 25, 55, 0.1);
            color: #E31937;
        }

        .knowledge-tree-children {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .knowledge-tree-children.expanded {
            max-height: 2000px;
        }

        /* ç»Ÿè®¡åˆ†æé¢æ¿ */
        .analysis-panel {
            background: linear-gradient(135deg, #ffffff, #fdfdff);
            border-radius: 12px;
            padding: 1rem;
            margin: 0.5rem 0;
            border: 1px solid #f1f5f9;
        }

        .analysis-chart {
            height: 120px;
            margin: 0.5rem 0;
        }

        .weakness-indicator {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
            margin-left: 0.5rem;
        }

        .weakness-high {
            background: #fef2f2;
            color: #dc2626;
        }

        .weakness-medium {
            background: #fef3c7;
            color: #d97706;
        }

        .weakness-low {
            background: #f0fdf4;
            color: #16a34a;
        }

        /* ç­›é€‰å™¨æ ·å¼ */
        .filter-controls {
            padding: 0.75rem 1.25rem;
            background: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
        }

        .filter-select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 0.75rem;
            margin-bottom: 0.5rem;
        }

        .filter-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
            margin-top: 0.5rem;
        }

        .filter-tag {
            background: #E31937;
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .filter-tag:hover {
            background: #c41e3a;
        }

        /* çŸ¥è¯†ç‚¹åˆ†å¸ƒå›¾è¡¨ */
        .knowledge-distribution {
            margin: 0.5rem 0;
        }

        .distribution-item {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
            padding: 0.25rem;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .distribution-item:hover {
            background: rgba(227, 25, 55, 0.05);
        }

        .distribution-bar {
            flex: 1;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            margin: 0 0.5rem;
            overflow: hidden;
        }

        .distribution-fill {
            height: 100%;
            background: linear-gradient(90deg, #E31937, #FF6B6B);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .distribution-label {
            font-size: 0.65rem;
            color: #374151;
            min-width: 80px;
        }

        .distribution-value {
            font-size: 0.65rem;
            color: #64748b;
            min-width: 30px;
            text-align: right;
        }

        /* å…¶ä»–åŸæœ‰æ ·å¼ä¿æŒä¸å˜ */
        .nav-controls { 
            padding: 0.75rem 1.25rem; 
            border-top: 1px solid #f1f5f9; 
            background: #f8fafc; 
            display: flex; 
            gap: 0.5rem; 
            margin-top: 0.5rem; 
        }
        
        .nav-controls:last-child { 
            border-radius: 0 0 18px 0; 
            border-top: none; 
            padding-top: 0.25rem; 
        }
        
        .nav-control-btn { 
            flex: 1; 
            padding: 0.5rem 0.75rem; 
            border-radius: 6px; 
            font-weight: 600; 
            font-size: 0.75rem; 
            transition: all 0.2s ease; 
            border: none; 
            cursor: pointer; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            gap: 0.3rem; 
        }
        
        .nav-control-btn i { 
            font-size: 0.7rem; 
        }
        
        .nav-control-primary { 
            background: linear-gradient(135deg, #10b981, #059669); 
            color: white; 
        }
        
        .nav-control-primary:hover { 
            background: linear-gradient(135deg, #059669, #047857); 
            transform: translateY(-1px); 
        }
        
        .nav-control-secondary { 
            background: linear-gradient(135deg, #6b7280, #4b5563); 
            color: white; 
        }
        
        .nav-control-secondary:hover { 
            background: linear-gradient(135deg, #4b5563, #374151); 
            transform: translateY(-1px); 
        }
        
        .nav-control-danger { 
            background: linear-gradient(135deg, #f87171, #ef4444); 
            color: white; 
        }
        
        .nav-control-danger:hover { 
            background: linear-gradient(135deg, #ef4444, #dc2626); 
            transform: translateY(-1px); 
        }
        
        .nav-stats { 
            padding: 1rem 0; 
            background: linear-gradient(135deg, #fdfdff, #f7f9fc); 
            border-radius: 8px; 
            margin: 0.5rem 1.25rem; 
        }
        
        .nav-stats-item { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-bottom: 0.6rem; 
            padding: 0 0.75rem; 
        }
        
        .nav-stats-item:last-child { 
            margin-bottom: 0; 
        }
        
        .nav-stats-label { 
            font-size: 0.75rem; 
            color: #64748b; 
            font-weight: 500; 
        }
        
        .nav-stats-value { 
            font-size: 0.8rem; 
            font-weight: 700; 
            color: #1e293b; 
            background: linear-gradient(135deg, #E31937, #FF6B6B); 
            -webkit-background-clip: text; 
            -webkit-text-fill-color: transparent; 
            background-clip: text; 
        }
        
        .nav-overall-progress-bar { 
            height: 6px; 
            background: #e2e8f0; 
            border-radius: 3px; 
            overflow: hidden; 
            margin: 0.5rem 0.75rem 0; 
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.05); 
        }
        
        .nav-overall-progress-fill { 
            height: 100%; 
            background: linear-gradient(90deg, #E31937, #FF8E8E); 
            transition: width 0.3s ease; 
            border-radius: 3px; 
            box-shadow: 0 1px 2px rgba(227, 25, 55, 0.2); 
        }
        
        .mobile-nav-toggle { 
            display: none; 
            position: fixed; 
            top: 1rem; 
            left: 1rem; 
            z-index: 1002; 
            background: #E31937; 
            color: white; 
            border: none; 
            border-radius: 50%; 
            width: 44px; 
            height: 44px; 
            cursor: pointer; 
            box-shadow: 0 4px 12px rgba(227, 25, 55, 0.3); 
            align-items: center; 
            justify-content: center; 
        }
        
        .mobile-nav-toggle i { 
            font-size: 1rem; 
        }
        
        .mobile-overlay { 
            display: none; 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background: rgba(0, 0, 0, 0.5); 
            z-index: 999; 
        }
        
        .question-card { 
            background: linear-gradient(135deg, #ffffff, #fdfdff); 
            border-radius: 16px; 
            padding: 2rem; 
            margin-bottom: 2rem; 
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08); 
            transition: all 0.3s ease; 
            border: 1px solid #f1f5f9; 
        }
        
        .question-card:hover { 
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12); 
            transform: translateY(-2px); 
        }
        
        .question-header { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-bottom: 1.5rem; 
            padding-bottom: 1rem; 
            border-bottom: 2px solid #f1f5f9; 
            flex-wrap: wrap; 
        } 
        
        .question-type-badge { 
            background: linear-gradient(135deg, #E31937, #FF6B6B); 
            color: white; 
            padding: 0.5rem 1rem; 
            border-radius: 20px; 
            font-size: 0.875rem; 
            font-weight: 600; 
            margin-bottom: 0.5rem; 
        } 
        
        .question-number { 
            font-size: 1.125rem; 
            font-weight: 700; 
            color: #374151; 
            margin-bottom: 0.5rem; 
        } 
        
        .question-difficulty { 
            display: flex; 
            align-items: center; 
            gap: 0.5rem; 
            color: #f59e0b; 
            font-size: 0.875rem; 
            font-weight: 500; 
            margin-bottom: 0.5rem;
        } 
        
        .question-content { 
            margin-bottom: 2rem; 
        }
        
        .question-text { 
            font-size: 1.125rem; 
            line-height: 1.7; 
            color: #1f2937; 
            margin-bottom: 1.5rem; 
            font-weight: 500; 
            white-space: pre-wrap; 
        } 
        
        .options-container { 
            display: grid; 
            gap: 1rem; 
        }
        
        .option { 
            padding: 1rem 1.25rem; 
            border: 2px solid #e5e7eb; 
            border-radius: 12px; 
            cursor: pointer; 
            transition: all 0.2s ease; 
            display: flex; 
            align-items: flex-start; 
            gap: 1rem; 
            background: #ffffff; 
        }
        
        .option:hover:not(.disabled) { 
            border-color: var(--primary-color); 
            background: #fef7f7; 
            transform: translateX(4px); 
        }
        
        .option.selected { 
            border-color: var(--primary-color); 
            background: linear-gradient(135deg, #fef7f7, #fff5f5); 
            box-shadow: 0 4px 12px rgba(227, 25, 55, 0.15); 
        }
        
        .option.correct { 
            border-color: var(--success-color); 
            background: var(--correct-bg); 
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.15); 
        }
        
        .option.wrong { 
            border-color: var(--error-color); 
            background: var(--wrong-bg); 
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.15); 
        }
        
        .option.disabled { 
            cursor: not-allowed; 
            opacity: 0.7; 
        }
        
        .option-label { 
            font-weight: 700; 
            font-size: 1.125rem; 
            color: var(--primary-color); 
            min-width: 2rem; 
            text-align: center; 
            margin-top: 0.125rem;  
        }
        
        .option.correct .option-label { 
            color: var(--success-color); 
        }
        
        .option.wrong .option-label { 
            color: var(--error-color); 
        }
        
        .option-text { 
            flex: 1; 
            font-size: 1rem; 
            line-height: 1.5; 
            color: #374151; 
            white-space: pre-wrap; 
        } 
        
        .option input[type="checkbox"], .option input[type="radio"] { 
            margin-right: 0.75rem; 
            width: 1.25rem; 
            height: 1.25rem; 
            accent-color: var(--primary-color); 
            margin-top: 0.25rem;  
        }
        
        .question-actions { 
            display: flex; 
            gap: 1rem; 
            justify-content: center; 
            margin-top: 2rem; 
        }
        
        .btn { 
            padding: 0.75rem 1.5rem; 
            border-radius: 10px; 
            font-weight: 600; 
            font-size: 0.875rem; 
            transition: all 0.2s ease; 
            border: none; 
            cursor: pointer; 
            display: flex; 
            align-items: center; 
            gap: 0.5rem; 
        }
        
        .btn-primary { 
            background: linear-gradient(135deg, #E31937, #FF6B6B); 
            color: white; 
        }
        
        .btn-primary:hover { 
            background: linear-gradient(135deg, #c41e3a, #E31937); 
            transform: translateY(-2px); 
            box-shadow: 0 4px 12px rgba(227, 25, 55, 0.3); 
        }
        
        .btn-secondary { 
            background: linear-gradient(135deg, #6b7280, #4b5563); 
            color: white; 
        }
        
        .btn-secondary:hover { 
            background: linear-gradient(135deg, #4b5563, #374151); 
            transform: translateY(-2px); 
            box-shadow: 0 4px 12px rgba(107, 114, 128, 0.3); 
        }
        
        .btn-success { 
            background: linear-gradient(135deg, #10b981, #059669); 
            color: white; 
        }
        
        .btn-success:hover { 
            background: linear-gradient(135deg, #059669, #047857); 
            transform: translateY(-2px); 
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3); 
        }
        
        .btn:disabled { 
            opacity: 0.5; 
            cursor: not-allowed; 
            transform: none !important; 
        }
        
        .answer-explanation { 
            margin-top: 2rem; 
            padding: 1.5rem; 
            background: linear-gradient(135deg, #f8fafc, #f1f5f9); 
            border-radius: 12px; 
            border-left: 4px solid var(--primary-color); 
            display: none; 
        }
        
        .answer-explanation.show { 
            display: block; 
            animation: slideDown 0.3s ease-out; 
        }
        
        @keyframes slideDown { 
            from { 
                opacity: 0; 
                transform: translateY(-10px); 
            } 
            to { 
                opacity: 1; 
                transform: translateY(0); 
            } 
        }
        
        .correct-answer { 
            margin-bottom: 1rem; 
        }
        
        .correct-answer h4 { 
            color: var(--success-color); 
            font-size: 1.125rem; 
            font-weight: 700; 
            margin-bottom: 0.5rem; 
        }
        
        .correct-answer h5 { 
            font-size: 1rem; 
            font-weight: 600; 
            margin-bottom: 0.5rem; 
        } 
        
        .explanation-content h5 { 
            color: #374151; 
            font-size: 1rem; 
            font-weight: 600; 
            margin-bottom: 0.75rem; 
        }
        
        .explanation-content p { 
            color: #4b5563; 
            line-height: 1.6; 
            margin-bottom: 1rem; 
            white-space: pre-wrap; 
        } 
        
        .knowledge-points { 
            margin-top: 1rem; 
            padding-top: 1rem; 
            border-top: 1px solid #e5e7eb; 
        }
        
        .knowledge-points h6 { 
            color: #374151; 
            font-size: 0.875rem; 
            font-weight: 600; 
            margin-bottom: 0.5rem; 
        }
        
        .tag { 
            display: inline-block; 
            background: linear-gradient(135deg, #E31937, #FF6B6B); 
            color: white; 
            padding: 0.25rem 0.75rem; 
            border-radius: 15px; 
            font-size: 0.75rem; 
            font-weight: 500; 
            margin-right: 0.5rem; 
            margin-bottom: 0.5rem; 
        }
        
        .stats-panel { 
            background: linear-gradient(135deg, #ffffff, #fdfdff); 
            border-radius: 1rem; 
            padding: 1.25rem; 
            margin-bottom: 1.5rem; 
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.05); 
            border: 1px solid #f1f5f9; 
        }
        
        .stats-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); 
            gap: 1rem; 
        }
        
        .stat-card { 
            background: #f8fafc; 
            border-radius: 0.75rem; 
            padding: 1rem; 
            text-align: center; 
            border: 1px solid #eef2f7; 
            transition: all 0.2s ease; 
        }
        
        .stat-card.clickable { 
            cursor: pointer; 
        }
        
        .stat-card:hover:not(.clickable) { 
            transform: none; 
            box-shadow: none; 
            border-color: #eef2f7; 
        }
        
        .stat-card.clickable:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.07); 
            border-color: #E31937; 
        }
        
        .stat-number { 
            font-size: 1.75rem; 
            font-weight: 700; 
            color: #E31937; 
            margin-bottom: 0.25rem; 
        }
        
        .stat-label { 
            font-size: 0.75rem; 
            color: #64748b; 
            font-weight: 500; 
        }
        
        .mode-selector { 
            display: flex; 
            gap: 1rem; 
            margin-bottom: 2rem; 
            flex-wrap: wrap; 
        }
        
        .mode-btn { 
            padding: 0.75rem 1.5rem; 
            border: 2px solid #e5e7eb; 
            border-radius: 10px; 
            background: white; 
            cursor: pointer; 
            transition: all 0.2s ease; 
            font-weight: 500; 
            color: #374151; 
        }
        
        .mode-btn.active { 
            border-color: var(--primary-color); 
            background: linear-gradient(135deg, #fef7f7, #fff5f5); 
            color: var(--primary-color); 
        }
        
        .mode-btn:hover { 
            border-color: var(--primary-color); 
            background: #fef7f7; 
        }
        
        .nav-panel::-webkit-scrollbar, body::-webkit-scrollbar { 
            width: 6px; 
        }
        
        .nav-panel::-webkit-scrollbar-track, body::-webkit-scrollbar-track { 
            background: #f1f5f9; 
            border-radius: 3px; 
        }
        
        .nav-panel::-webkit-scrollbar-thumb, body::-webkit-scrollbar-thumb { 
            background: linear-gradient(135deg, #E31937, #FF6B6B); 
            border-radius: 3px; 
        }
        
        .nav-panel::-webkit-scrollbar-thumb:hover, body::-webkit-scrollbar-thumb:hover { 
            background: linear-gradient(135deg, #c41e3a, #E31937); 
        }
        
        #scrollToTopBtn { 
            position: fixed; 
            bottom: 30px; 
            right: 30px; 
            z-index: 1000; 
            background-color: #E31937; 
            color: white; 
            border: none; 
            border-radius: 50%; 
            width: 50px; 
            height: 50px; 
            font-size: 1.2rem; 
            cursor: pointer; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.15); 
            display: none; 
            align-items: center; 
            justify-content: center; 
            transition: opacity 0.3s, transform 0.3s; 
        }
        
        #scrollToTopBtn:hover { 
            background-color: #c41e3a; 
            transform: scale(1.1); 
        }
        
        /* é”®ç›˜å¿«æ·é”®æç¤º */
        .keyboard-hints {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 1rem;
            border-radius: 8px;
            font-size: 0.75rem;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        
        .keyboard-hints.show {
            opacity: 1;
            visibility: visible;
        }
        
        .keyboard-hints h6 {
            margin-bottom: 0.5rem;
            font-weight: 600;
        }
        
        .keyboard-hints div {
            margin-bottom: 0.25rem;
        }
        
        .keyboard-hints kbd {
            background: #374151;
            padding: 0.125rem 0.25rem;
            border-radius: 3px;
            font-family: monospace;
        }
        
        @media (max-width: 1024px) {
            .floating-nav {
                display: none;
            }
            .mobile-nav-toggle {
                display: flex;
            }
            .nav-panel.mobile-open {
                position: fixed;
                left: 0;
                top: 0;
                width: 100%;
                max-width: 420px;
                height: 100vh;
                transform: none;
                opacity: 1;
                visibility: visible;
                border-radius: 0;
                z-index: 1000;
            }
        }
        
        @media (max-width: 768px) {
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            .mode-selector {
                flex-direction: column;
            }
            .question-header {
                flex-direction: column;
                align-items: flex-start;
            }
            .keyboard-hints {
                display: none;
            }
        }
        
        #loading-indicator { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background-color: rgba(243, 244, 246, 0.98); 
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            z-index: 9999; 
            font-size: 1.25rem; 
            color: #E31937; 
            font-weight: 600; 
            text-align: center; 
        }
        
        #loading-indicator i { 
            font-size: 2.5rem; 
            margin-bottom: 1rem; 
        }
        
        main.hidden-initial { 
            visibility: hidden; 
        }

        .upload-section-hidden { 
            display: none; 
        }
        
        #trigger-upload-area { 
            cursor: pointer; 
            text-align: center; 
            color: var(--primary-color); 
            font-weight: 500; 
            padding: 2rem; 
            border: 2px dashed #ccc; 
            border-radius: 0.5rem; 
            margin-bottom: 2rem; 
            transition: all 0.2s ease; 
        }
        
        #trigger-upload-area:hover { 
            border-color: var(--primary-color); 
            background-color: #fef7f7; 
        }
        
        #upload-status-main { 
            text-align: center; 
            margin-bottom: 1rem; 
            font-weight: 500; 
            min-height: 1.5em; 
        }
        
        .footer-upload-trigger { 
            text-align: center; 
            padding: 1rem; 
            font-size: 0.9rem; 
            color: #666; 
        }
        
        .footer-upload-trigger a { 
            color: var(--primary-color); 
            text-decoration: underline; 
            cursor: pointer; 
        }

        /* é”™è¯¯æç¤ºæ ·å¼ */
        .error-prompt {
            background: linear-gradient(135deg, #fef2f2, #fee2e2);
            border: 2px dashed #fca5a5;
            border-radius: 12px;
            padding: 2rem;
            text-align: center;
            margin-bottom: 2rem;
        }

        .error-prompt h3 {
            color: #dc2626;
            font-size: 1.25rem;
            font-weight: 700;
            margin-bottom: 1rem;
        }

        .error-prompt .error-details {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            text-align: left;
        }

        .error-prompt .error-details ul {
            margin: 0.5rem 0;
            padding-left: 1.5rem;
        }

        .error-prompt .error-details li {
            margin-bottom: 0.25rem;
            color: #374151;
        }

        /* åŠ è½½çŠ¶æ€æ ·å¼ */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            border-radius: 12px;
        }

        .loading-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            border: 3px solid #f3f4f6;
            border-radius: 50%;
            border-top-color: #E31937;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* è°ƒè¯•ä¿¡æ¯æ ·å¼ */
        .debug-info {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            font-family: monospace;
            font-size: 0.75rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .debug-info h6 {
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #374151;
        }

        .debug-info pre {
            white-space: pre-wrap;
            word-break: break-all;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">
    
    <div id="loading-indicator">
        <i class="fas fa-spinner fa-spin"></i>
        <span>åŠ è½½ä¸­ï¼Œè¯·ç¨å€™...</span>
    </div>

    <input type="file" id="csv-upload-input" accept=".csv" class="hidden">

    <button id="mobile-nav-toggle" class="mobile-nav-toggle">
        <i class="fas fa-bars"></i>
    </button>
    <div id="mobile-overlay" class="mobile-overlay"></div>

    <!-- é”®ç›˜å¿«æ·é”®æç¤º -->
    <div id="keyboard-hints" class="keyboard-hints">
        <h6><i class="fas fa-keyboard"></i> é”®ç›˜å¿«æ·é”®</h6>
        <div><kbd>â†‘</kbd> <kbd>â†“</kbd> ä¸Šä¸€é¢˜/ä¸‹ä¸€é¢˜</div>
        <div><kbd>Enter</kbd> æäº¤ç­”æ¡ˆ</div>
        <div><kbd>Space</kbd> æ˜¾ç¤ºè§£æ</div>
        <div><kbd>1-4</kbd> <kbd>A-D</kbd> é€‰æ‹©é€‰é¡¹</div>
        <div><kbd>H</kbd> æ˜¾ç¤º/éšè—æ­¤æç¤º</div>
    </div>

    <div id="floating-nav" class="floating-nav collapsed">
        <div id="nav-trigger" class="nav-trigger">
            <i class="fas fa-chevron-right"></i>
        </div>
        <div id="nav-panel" class="nav-panel">
            <div class="nav-header">
                <div class="nav-title">
                    <i class="fas fa-graduation-cap"></i>
                    é¢˜é›†å¯¼èˆª
                </div>
                <div class="nav-subtitle">æ™ºèƒ½ç»ƒä¹ ç³»ç»Ÿ</div>
            </div>

            <!-- çŸ¥è¯†æ ‘ç­›é€‰å™¨ -->
            <div class="filter-controls">
                <select id="knowledge-level-filter" class="filter-select">
                    <option value="">é€‰æ‹©çŸ¥è¯†æ ‘å±‚çº§</option>
                    <option value="1">ä¸€çº§çŸ¥è¯†æ ‘</option>
                    <option value="2">äºŒçº§çŸ¥è¯†æ ‘</option>
                    <option value="3">ä¸‰çº§çŸ¥è¯†æ ‘</option>
                </select>
                <select id="knowledge-point-filter" class="filter-select">
                    <option value="">é€‰æ‹©çŸ¥è¯†ç‚¹</option>
                </select>
                <div class="filter-tags" id="active-filters"></div>
            </div>

            <div class="nav-content">
                <div class="nav-section">
                    <div class="nav-section-title">ç»ƒä¹ æ¨¡å¼</div>
                    <div id="nav-mode-list">
                        <a href="#" class="nav-item" data-mode="sequential">
                            <div class="nav-item-icon">ğŸ“š</div>
                            <div class="nav-item-content">
                                <div class="nav-item-name">é¡ºåºç»ƒä¹ </div>
                            </div>
                        </a>
                        <a href="#" class="nav-item" data-mode="random">
                            <div class="nav-item-icon">ğŸ²</div>
                            <div class="nav-item-content">
                                <div class="nav-item-name">éšæœºç»ƒä¹ </div>
                            </div>
                        </a>
                        <a href="#" class="nav-item" data-mode="wrong">
                            <div class="nav-item-icon">âŒ</div>
                            <div class="nav-item-content">
                                <div class="nav-item-name">é”™é¢˜é‡åš</div>
                            </div>
                        </a>
                        <a href="#" class="nav-item" data-mode="knowledge">
                            <div class="nav-item-icon">ğŸ§ </div>
                            <div class="nav-item-content">
                                <div class="nav-item-name">æŒ‰çŸ¥è¯†ç‚¹ç»ƒä¹ </div>
                            </div>
                        </a>
                         <a href="#" class="nav-item" data-mode="subject">
                            <div class="nav-item-icon">ğŸ—‚ï¸</div>
                            <div class="nav-item-content">
                                <div class="nav-item-name">æŒ‰ç§‘ç›®ç»ƒä¹ </div>
                            </div>
                        </a>
                        <a href="#" class="nav-item" data-mode="type">
                            <div class="nav-item-icon">ğŸ“</div>
                            <div class="nav-item-content">
                                <div class="nav-item-name">æŒ‰é¢˜å‹ç»ƒä¹ </div>
                            </div>
                        </a>
                    </div>
                </div>
                
                <div class="nav-section">
                    <div class="nav-section-title">ç§‘ç›®åˆ†ç±»</div>
                     <div id="dynamic-subject-list">
                        <!-- åŠ¨æ€ç”Ÿæˆç§‘ç›®åˆ—è¡¨ -->
                    </div>
                </div>

                <div class="nav-section">
                    <div class="nav-section-title">é¢˜å‹åˆ†ç±»</div>
                    <div id="dynamic-type-list">
                        <!-- åŠ¨æ€ç”Ÿæˆé¢˜å‹åˆ—è¡¨ -->
                    </div>
                </div>
                
                <div class="nav-section">
                    <div class="nav-section-title">
                        çŸ¥è¯†æ ‘å¯¼èˆª
                        <button id="toggle-analysis" class="knowledge-tree-toggle">
                            <i class="fas fa-chart-bar"></i>
                        </button>
                    </div>

                    <!-- è–„å¼±ç‚¹åˆ†æé¢æ¿ -->
                    <div id="weakness-analysis" class="analysis-panel" style="display: none;">
                        <h6 style="font-size: 0.75rem; font-weight: 600; margin-bottom: 0.5rem; color: #374151;">
                            <i class="fas fa-exclamation-triangle"></i> è–„å¼±ç‚¹åˆ†æ
                        </h6>
                        <div id="weakness-list"></div>
                    </div>

                    <!-- çŸ¥è¯†ç‚¹åˆ†å¸ƒåˆ†æ -->
                    <div id="knowledge-distribution" class="analysis-panel">
                        <h6 style="font-size: 0.75rem; font-weight: 600; margin-bottom: 0.5rem; color: #374151;">
                            <i class="fas fa-pie-chart"></i> çŸ¥è¯†ç‚¹åˆ†å¸ƒ
                        </h6>
                        <div id="distribution-chart"></div>
                    </div>

                    <div id="dynamic-knowledge-tree">
                        <!-- åŠ¨æ€ç”ŸæˆçŸ¥è¯†æ ‘ -->
                    </div>
                </div>
                
                <div class="nav-section">
                    <div class="nav-section-title">å­¦ä¹ ç»Ÿè®¡</div>
                    <div class="nav-stats">
                        <div class="nav-stats-item">
                            <span class="nav-stats-label">å·²å®Œæˆ</span>
                            <span class="nav-stats-value" id="nav-completed">0</span>
                        </div>
                        <div class="nav-stats-item">
                            <span class="nav-stats-label">æ­£ç¡®ç‡</span>
                            <span class="nav-stats-value" id="nav-accuracy">0%</span>
                        </div>
                        <div class="nav-stats-item">
                            <span class="nav-stats-label">æ€»é¢˜æ•°</span>
                            <span class="nav-stats-value" id="nav-total">0</span>
                        </div>
                        <div class="nav-overall-progress-bar">
                            <div class="nav-overall-progress-fill" id="nav-progress" style="width: 0%"></div>
                        </div>
                    </div>
                    
                    <div class="nav-controls">
                        <button class="nav-control-btn nav-control-primary" id="export-wrong-questions">
                            <i class="fas fa-download"></i>
                            å¯¼å‡ºé”™é¢˜
                        </button>
                        <button class="nav-control-btn nav-control-secondary" id="nav-review-mode">
                            <i class="fas fa-redo"></i>
                            é”™é¢˜é‡åš
                        </button>
                    </div>
                    <div class="nav-controls">
                        <button class="nav-control-btn nav-control-danger" id="reset-progress-btn" style="flex-basis: 100%;">
                            <i class="fas fa-undo"></i>
                            é‡ç½®è¿›åº¦
                        </button>
                    </div>
                     <div class="nav-controls">
                        <button class="nav-control-btn nav-control-secondary" id="trigger-upload-from-nav" style="flex-basis: 100%;">
                            <i class="fas fa-file-upload"></i>
                            åŠ è½½/æ›´æ¢é¢˜åº“
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="min-h-screen bg-gray-100">
        <div class="bg-gradient-to-br from-red-700 via-red-600 to-pink-600 text-white relative overflow-hidden shadow-lg">
            <div class="absolute inset-0 bg-black opacity-10"></div>
            <div class="container mx-auto px-6 py-16 md:py-24 relative z-10">
                <h1 class="text-5xl md:text-7xl font-black mb-4 tracking-tight text-center md:text-left">
                    <span class="gradient-text" style="background: linear-gradient(135deg, #fff7f7, #ffebeb); -webkit-background-clip: text; background-clip: text;">åŒ»å­¦çŸ¥è¯†</span>
                    <span class="block text-white">æç®€æ™ºèƒ½åˆ·é¢˜åº“</span>
                </h1>
                <p class="text-lg md:text-xl mb-8 text-red-100 max-w-2xl leading-relaxed text-center md:text-left">
                    ä¸“æ³¨ã€é«˜æ•ˆã€æ™ºèƒ½ã€‚å¤šç§ç»ƒä¹ æ¨¡å¼ï¼Œå®æ—¶ç»Ÿè®¡å­¦ä¹ è¿›åº¦ï¼ŒåŠ©æ‚¨è½»æ¾å¤‡è€ƒã€‚
                </p>
            </div>
        </div>

        <div class="container mx-auto px-4 md:px-6 -mt-10 md:-mt-12 relative z-20">
            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-card" id="total-questions-card">
                        <div class="stat-number" id="total-questions">0</div>
                        <div class="stat-label">æ€»é¢˜æ•°</div>
                    </div>
                    <div class="stat-card clickable" id="completed-questions-card">
                        <div class="stat-number" id="completed-questions">0</div>
                        <div class="stat-label">å·²å®Œæˆ</div>
                    </div>
                    <div class="stat-card clickable" id="correct-questions-card">
                        <div class="stat-number" id="correct-questions">0</div>
                        <div class="stat-label">ç­”å¯¹é¢˜æ•°</div>
                    </div>
                    <div class="stat-card" id="accuracy-card">
                        <div class="stat-number" id="accuracy-rate">0%</div>
                        <div class="stat-label">æ­£ç¡®ç‡</div>
                    </div>
                    <div class="stat-card clickable" id="wrong-questions-card">
                        <div class="stat-number" id="wrong-questions">0</div>
                        <div class="stat-label">é”™é¢˜æ•°</div>
                    </div>
                </div>
            </div>
        </div>

        <main id="main-content-wrapper" class="container mx-auto px-4 md:px-6 py-8 hidden-initial">
            <div class="max-w-4xl mx-auto">
                <div id="upload-status-main"></div> 

                <div class="mode-selector">
                    <button class="mode-btn active" data-mode="sequential">é¡ºåºç»ƒä¹ </button>
                    <button class="mode-btn" data-mode="random">éšæœºç»ƒä¹ </button>
                    <button class="mode-btn" data-mode="wrong">é”™é¢˜é‡åš</button>
                    <button class="mode-btn" data-mode="knowledge">æŒ‰çŸ¥è¯†ç‚¹ç»ƒä¹ </button>
                    <button class="mode-btn" data-mode="subject">æŒ‰ç§‘ç›®ç»ƒä¹ </button>
                    <button class="mode-btn" data-mode="type">æŒ‰é¢˜å‹ç»ƒä¹ </button>
                </div>

                <div id="question-container">
                </div>

                <div class="flex justify-between items-center mt-8">
                    <button id="prev-btn" class="btn btn-secondary" disabled>
                        <i class="fas fa-chevron-left"></i>
                        ä¸Šä¸€é¢˜
                    </button>
                    <span id="question-counter" class="text-gray-600 font-medium">0 / 0</span>
                    <button id="next-btn" class="btn btn-primary" disabled>
                        ä¸‹ä¸€é¢˜
                        <i class="fas fa-chevron-right"></i>
                    </button>
                </div>
            </div>
        </main>
        <footer class="text-center p-6 text-gray-500 text-sm">
            <p>Â© 2024 æç®€æ™ºèƒ½åˆ·é¢˜åº“. <span id="footer-upload-trigger-container"></span></p>
        </footer>
    </div>

    <button id="scrollToTopBtn" title="å›åˆ°é¡¶éƒ¨">
        <i class="fas fa-arrow-up"></i>
    </button>

    <script>
        // åˆå§‹åŒ–ç©ºé¢˜ç›®æ•°æ®
        let questionsData = [];
        const STORED_QUESTIONS_KEY = 'storedMedicalQuestions';
        const STORED_FILE_HASH_KEY = 'storedMedicalFileHash';

        // QuizSystem ç±»
        class QuizSystem {
            constructor() {
                this.questions = []; 
                this.currentQuestionIndex = 0;
                this.userAnswers = {}; 
                this.currentMode = 'sequential';
                this.filteredQuestions = [];
                this.knowledgeTreeData = {};
                this.activeFilters = [];
                this.statistics = {
                    total: 0,
                    completed: 0,
                    correct: 0,
                    wrong: 0,
                    accuracy: 0
                };
                
                this.LOCAL_STORAGE_KEY_PREFIX = 'medicalQuizProg_'; 
                this.currentFileHash = null; 
                this.eventsBound = false;
                this.keyboardHintsVisible = false;
            }

            initializeQuiz(loadedQuestions, fileHash, fromLocalStorage = false) {
                console.log('å¼€å§‹åˆå§‹åŒ–é¢˜åº“:', {
                    questionsCount: loadedQuestions.length,
                    fileHash: fileHash,
                    fromLocalStorage: fromLocalStorage
                });

                this.questions = loadedQuestions;
                this.userAnswers = {}; 
                this.currentQuestionIndex = 0;
                this.currentFileHash = fileHash;
                
                if (!fromLocalStorage) { 
                    localStorage.setItem(STORED_QUESTIONS_KEY, JSON.stringify(loadedQuestions));
                    localStorage.setItem(STORED_FILE_HASH_KEY, fileHash);
                }

                this.loadProgress(); 
                this.buildKnowledgeTree();
                this.filterQuestions(); // Filter before rendering
                this.updateStatistics(); // Update stats after loading progress
                this.renderQuestion();
                this.updateNavigation();
                this.bindEventsOnce(); 
                this.setupKeyboardShortcuts();
                document.getElementById('upload-status-main').textContent = `é¢˜åº“å·²åŠ è½½ (${loadedQuestions.length}é¢˜).`;
                document.getElementById('upload-status-main').className = 'text-green-500 text-center mb-4';
                this.updateFooterUploadTrigger(true); 

                console.log('é¢˜åº“åˆå§‹åŒ–å®Œæˆ');
            }

            // æ„å»ºçŸ¥è¯†æ ‘æ•°æ®ç»“æ„
            buildKnowledgeTree() {
                this.knowledgeTreeData = {};
                
                this.questions.forEach(q => {
                    const level1 = q.originalData?.çŸ¥è¯†æ ‘1 || q.subject || 'ç»¼åˆ';
                    const level2 = q.originalData?.çŸ¥è¯†æ ‘2 || '';
                    const level3 = q.originalData?.çŸ¥è¯†æ ‘3 || '';
                    
                    if (!this.knowledgeTreeData[level1]) {
                        this.knowledgeTreeData[level1] = {
                            name: level1,
                            questions: [],
                            children: {},
                            stats: { total: 0, answered: 0, correct: 0 },
                            expanded: false
                        };
                    }
                    
                    this.knowledgeTreeData[level1].questions.push(q);
                    this.knowledgeTreeData[level1].stats.total++;
                    
                    if (level2) {
                        if (!this.knowledgeTreeData[level1].children[level2]) {
                            this.knowledgeTreeData[level1].children[level2] = {
                                name: level2,
                                questions: [],
                                children: {},
                                stats: { total: 0, answered: 0, correct: 0 },
                                expanded: false
                            };
                        }
                        
                        this.knowledgeTreeData[level1].children[level2].questions.push(q);
                        this.knowledgeTreeData[level1].children[level2].stats.total++;
                        
                        if (level3) {
                            if (!this.knowledgeTreeData[level1].children[level2].children[level3]) {
                                this.knowledgeTreeData[level1].children[level2].children[level3] = {
                                    name: level3,
                                    questions: [],
                                    children: {}, // Level 3 nodes don't have children in this model
                                    stats: { total: 0, answered: 0, correct: 0 },
                                    expanded: false // Not really applicable but consistent
                                };
                            }
                            
                            this.knowledgeTreeData[level1].children[level2].children[level3].questions.push(q);
                            this.knowledgeTreeData[level1].children[level2].children[level3].stats.total++;
                        }
                    }
                });
                
                this.updateKnowledgeTreeStats();
                this.updateKnowledgePointFilter();
                this.renderKnowledgeTree();
                this.renderKnowledgeDistribution();
            }

            // æ¸²æŸ“çŸ¥è¯†æ ‘
            renderKnowledgeTree() {
                const container = document.getElementById('dynamic-knowledge-tree');
                if (!container) return;
                
                container.innerHTML = '';
                
                Object.values(this.knowledgeTreeData).sort((a,b) => a.name.localeCompare(b.name)).forEach(level1Node => {
                    this.renderKnowledgeNode(container, level1Node, 1);
                });
            }

            // æ¸²æŸ“çŸ¥è¯†æ ‘èŠ‚ç‚¹
            renderKnowledgeNode(container, node, level) {
                const progress = node.stats.total > 0 ? Math.round((node.stats.answered / node.stats.total) * 100) : 0;
                const accuracy = node.stats.answered > 0 ? Math.round((node.stats.correct / node.stats.answered) * 100) : 0;
                
                // è®¡ç®—è–„å¼±ç¨‹åº¦
                let weaknessLevel = '';
                if (node.stats.answered >= 3) { // Only show indicator if enough questions answered
                    if (accuracy < 40) weaknessLevel = 'high';
                    else if (accuracy < 60) weaknessLevel = 'medium';
                    // else if (accuracy < 80) weaknessLevel = 'low'; // Optional: show for "low" weakness too
                }
                
                const hasChildren = Object.keys(node.children).length > 0;
                const nodeElement = document.createElement('div');
                
                const navItem = document.createElement('a');
                navItem.href = '#';
                navItem.className = `nav-item knowledge-tree-level-${level}`;
                navItem.dataset.knowledgeNode = JSON.stringify({
                    name: node.name,
                    level: level
                });
                
                navItem.innerHTML = `
                    <div class="nav-item-icon">
                        ${hasChildren ? 
                            `<button class="knowledge-tree-toggle" data-node-name="${node.name.replace(/"/g, '&quot;')}" data-level="${level}">
                                <i class="fas fa-chevron-${node.expanded ? 'down' : 'right'}"></i>
                            </button>` : 
                            level === 1 ? 'ğŸ“š' : level === 2 ? 'ğŸ“–' : 'ğŸ“„'
                        }
                    </div>
                    <div class="nav-item-content">
                        <div class="nav-item-name">
                            ${node.name}
                            ${weaknessLevel ? `<span class="weakness-indicator weakness-${weaknessLevel}">${accuracy}%</span>` : ''}
                        </div>
                        <div class="nav-item-progress">
                            <div class="mini-progress-bar">
                                <div class="mini-progress-fill" style="width: ${progress}%;"></div>
                            </div>
                            <span class="nav-item-count">${node.stats.total}é¢˜</span>
                        </div>
                    </div>
                `;
                
                nodeElement.appendChild(navItem);
                
                // æ·»åŠ å­èŠ‚ç‚¹å®¹å™¨
                if (hasChildren) {
                    const childrenContainer = document.createElement('div');
                    childrenContainer.className = `knowledge-tree-children ${node.expanded ? 'expanded' : ''}`;
                    childrenContainer.id = `children-${node.name.replace(/[^a-zA-Z0-9]/g, '-')}-${level}`; // Ensure valid ID
                    
                    Object.values(node.children).sort((a,b) => a.name.localeCompare(b.name)).forEach(childNode => {
                        this.renderKnowledgeNode(childrenContainer, childNode, level + 1);
                    });
                    
                    nodeElement.appendChild(childrenContainer);
                }
                
                container.appendChild(nodeElement);
            }

            // æ¸²æŸ“çŸ¥è¯†ç‚¹åˆ†å¸ƒå›¾è¡¨
            renderKnowledgeDistribution() {
                const container = document.getElementById('distribution-chart');
                if (!container) return;
                
                container.innerHTML = '';
                
                // è·å–ä¸€çº§çŸ¥è¯†ç‚¹æ•°æ®
                const level1Data = Object.values(this.knowledgeTreeData).map(node => ({
                    name: node.name,
                    total: node.stats.total,
                    answered: node.stats.answered,
                    correct: node.stats.correct
                })).sort((a, b) => b.total - a.total); // Sort by total questions descending
                
                if (level1Data.length === 0) return;

                const maxTotal = Math.max(...level1Data.map(d => d.total));
                
                level1Data.forEach(data => {
                    const item = document.createElement('div');
                    item.className = 'distribution-item';
                    
                    const percentage = maxTotal > 0 ? (data.total / maxTotal) * 100 : 0;
                    // const accuracy = data.answered > 0 ? Math.round((data.correct / data.answered) * 100) : 0;
                    
                    item.innerHTML = `
                        <div class="distribution-label" title="${data.name}">${data.name.length > 10 ? data.name.substring(0,10)+'...' : data.name}</div>
                        <div class="distribution-bar">
                            <div class="distribution-fill" style="width: ${percentage}%;"></div>
                        </div>
                        <div class="distribution-value">${data.total}</div>
                    `;
                    
                    item.onclick = () => {
                        this.addFilter('1', data.name);
                        this.closeFloatingNav();
                    };
                    
                    container.appendChild(item);
                });
            }

            // æ›´æ–°çŸ¥è¯†æ ‘ç»Ÿè®¡æ•°æ®
            updateKnowledgeTreeStats() {
                const updateNodeStats = (node) => {
                    node.stats.answered = 0;
                    node.stats.correct = 0;
                    
                    node.questions.forEach(q => {
                        if (this.userAnswers[q.id]) {
                            node.stats.answered++;
                            if (this.userAnswers[q.id].isCorrect) {
                                node.stats.correct++;
                            }
                        }
                    });
                    
                    Object.values(node.children).forEach(child => {
                        updateNodeStats(child);
                    });
                };
                
                Object.values(this.knowledgeTreeData).forEach(node => {
                    updateNodeStats(node);
                });
            }

            // åˆ‡æ¢çŸ¥è¯†æ ‘èŠ‚ç‚¹å±•å¼€çŠ¶æ€
            toggleKnowledgeNode(nodeName, level) {
                const findAndToggleNode = (currentNodes, targetName, currentLevel) => {
                    for (const key in currentNodes) {
                        const node = currentNodes[key];
                        if (node.name === targetName && currentLevel === level) {
                            node.expanded = !node.expanded;
                            return true;
                        }
                        if (Object.keys(node.children).length > 0) {
                           if (findAndToggleNode(node.children, targetName, currentLevel + 1)) {
                               return true;
                           }
                        }
                    }
                    return false;
                };
                
                findAndToggleNode(this.knowledgeTreeData, nodeName, 1);
                this.renderKnowledgeTree();
            }

            // æ›´æ–°çŸ¥è¯†ç‚¹ç­›é€‰å™¨
            updateKnowledgePointFilter() {
                const levelFilter = document.getElementById('knowledge-level-filter');
                const pointFilter = document.getElementById('knowledge-point-filter');
                
                if (!levelFilter || !pointFilter) return;
                
                const selectedLevel = levelFilter.value;
                pointFilter.innerHTML = '<option value="">é€‰æ‹©çŸ¥è¯†ç‚¹</option>';
                
                if (!selectedLevel) return;
                
                const getNodesAtLevel = (level) => {
                    const nodes = [];
                    
                    if (level === '1') {
                        return Object.values(this.knowledgeTreeData).map(n => n.name);
                    } else if (level === '2') {
                        Object.values(this.knowledgeTreeData).forEach(node => {
                            nodes.push(...Object.values(node.children).map(n => n.name));
                        });
                    } else if (level === '3') {
                        Object.values(this.knowledgeTreeData).forEach(node => {
                            Object.values(node.children).forEach(child => {
                                nodes.push(...Object.values(child.children).map(n => n.name));
                            });
                        });
                    }
                    
                    return [...new Set(nodes)].filter(Boolean).sort((a,b) => a.localeCompare(b));
                };
                
                const points = getNodesAtLevel(selectedLevel);
                points.forEach(point => {
                    const option = document.createElement('option');
                    option.value = point;
                    option.textContent = point;
                    pointFilter.appendChild(option);
                });
            }

            // æ·»åŠ ç­›é€‰å™¨
            addFilter(level, point) {
                const filterId = `${level}-${point}`;
                if (this.activeFilters.find(f => f.id === filterId)) return;
                
                this.activeFilters.push({ id: filterId, level, point });
                this.updateFilterTags();
                this.switchMode('knowledge'); // Switch to knowledge mode when filter is added
            }

            // ç§»é™¤ç­›é€‰å™¨
            removeFilter(filterId) {
                this.activeFilters = this.activeFilters.filter(f => f.id !== filterId);
                this.updateFilterTags();
                if (this.activeFilters.length === 0 && this.currentMode === 'knowledge') {
                    this.switchMode('sequential'); // Or some default mode
                } else {
                    this.filterQuestions();
                    this.currentQuestionIndex = 0;
                    this.renderQuestion();
                    this.updateNavigation();
                }
            }

            // æ›´æ–°ç­›é€‰æ ‡ç­¾æ˜¾ç¤º
            updateFilterTags() {
                const container = document.getElementById('active-filters');
                if (!container) return;
                
                container.innerHTML = '';
                this.activeFilters.forEach(filter => {
                    const tag = document.createElement('div');
                    tag.className = 'filter-tag';
                    tag.innerHTML = `${filter.point} <i class="fas fa-times ml-1"></i>`;
                    tag.onclick = () => this.removeFilter(filter.id);
                    container.appendChild(tag);
                });
            }

            // åˆ†æè–„å¼±ç‚¹
            analyzeWeaknesses() {
                const weaknesses = [];
                
                const analyzeNode = (node, path = []) => {
                    if (node.stats.answered > 0) {
                        const accuracy = (node.stats.correct / node.stats.answered) * 100;
                        const fullPath = [...path, node.name].join(' > ');
                        
                        if (accuracy < 60 && node.stats.answered >= 3) { // Thresholds for weakness
                            weaknesses.push({
                                path: fullPath,
                                accuracy: accuracy,
                                answered: node.stats.answered,
                                total: node.stats.total,
                                level: accuracy < 40 ? 'high' : 'medium' // Simplified to high/medium
                            });
                        }
                    }
                    
                    Object.values(node.children).forEach(child => {
                        analyzeNode(child, [...path, node.name]);
                    });
                };
                
                Object.values(this.knowledgeTreeData).forEach(node => {
                    analyzeNode(node);
                });
                
                return weaknesses.sort((a, b) => a.accuracy - b.accuracy); // Sort by lowest accuracy first
            }

            // æ›´æ–°è–„å¼±ç‚¹åˆ†ææ˜¾ç¤º
            updateWeaknessAnalysis() {
                const container = document.getElementById('weakness-list');
                if (!container) return;
                
                const weaknesses = this.analyzeWeaknesses();
                
                if (weaknesses.length === 0) {
                    container.innerHTML = '<div style="font-size: 0.7rem; color: #10b981;">æš‚æ— æ˜æ˜¾è–„å¼±ç‚¹</div>';
                    return;
                }
                
                container.innerHTML = '';
                weaknesses.slice(0, 5).forEach(weakness => { // Show top 5 weaknesses
                    const item = document.createElement('div');
                    item.style.cssText = 'margin-bottom: 0.5rem; font-size: 0.7rem; cursor: pointer;';
                    item.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span style="flex: 1; margin-right: 0.5rem;" title="${weakness.path}">${weakness.path.length > 35 ? weakness.path.substring(0,35)+'...' : weakness.path}</span>
                            <span class="weakness-indicator weakness-${weakness.level}">
                                ${Math.round(weakness.accuracy)}%
                            </span>
                        </div>
                    `;
                    
                    item.onclick = () => {
                        const pathParts = weakness.path.split(' > ');
                        this.activeFilters = []; // Clear existing filters for focused practice
                        pathParts.forEach((part, index) => {
                            this.addFilter((index + 1).toString(), part);
                        });
                        this.closeFloatingNav();
                    };
                    
                    container.appendChild(item);
                });
            }
            
            bindEventsOnce() {
                if (this.eventsBound) return;
                this.bindEvents();
                this.eventsBound = true;
            }

            bindEvents() {
                // Main mode buttons
                document.querySelectorAll('.mode-selector .mode-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        if (!this.questions.length) {
                            alert('è¯·å…ˆåŠ è½½é¢˜åº“ï¼');
                            document.getElementById('csv-upload-input').click();
                            return;
                        }
                        this.switchMode(e.target.dataset.mode);
                    });
                });

                // Nav panel mode buttons
                document.querySelectorAll('#nav-mode-list .nav-item').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.preventDefault();
                        const mode = e.currentTarget.dataset.mode;
                        if (!this.questions.length && mode !== 'upload') { // Allow upload even without questions
                            alert('è¯·å…ˆåŠ è½½é¢˜åº“ï¼');
                            document.getElementById('csv-upload-input').click();
                            this.closeFloatingNav();
                            return;
                        }
                        this.switchMode(mode);
                        this.closeFloatingNav();
                    });
                });

                // Knowledge tree filter events
                const levelFilter = document.getElementById('knowledge-level-filter');
                const pointFilter = document.getElementById('knowledge-point-filter');
                
                if (levelFilter) {
                    levelFilter.addEventListener('change', () => {
                        this.updateKnowledgePointFilter();
                    });
                }
                
                if (pointFilter) {
                    pointFilter.addEventListener('change', () => {
                        const level = levelFilter.value;
                        const point = pointFilter.value;
                        if (level && point) {
                            this.addFilter(level, point);
                            pointFilter.value = ''; // Reset after selection
                        }
                    });
                }

                // Weakness analysis toggle
                const toggleAnalysis = document.getElementById('toggle-analysis');
                const weaknessAnalysis = document.getElementById('weakness-analysis');
                
                if (toggleAnalysis && weaknessAnalysis) {
                    toggleAnalysis.addEventListener('click', () => {
                        const isVisible = weaknessAnalysis.style.display !== 'none';
                        weaknessAnalysis.style.display = isVisible ? 'none' : 'block';
                        if (!isVisible) {
                            this.updateWeaknessAnalysis();
                        }
                    });
                }

                // Prev/Next buttons
                document.getElementById('prev-btn').addEventListener('click', () => this.previousQuestion());
                document.getElementById('next-btn').addEventListener('click', () => this.nextQuestion());
                
                // Nav panel control buttons
                document.getElementById('reset-progress-btn').addEventListener('click', () => this.resetProgress());
                document.getElementById('trigger-upload-from-nav').addEventListener('click', () => {
                    document.getElementById('csv-upload-input').click();
                });
                document.getElementById('export-wrong-questions').addEventListener('click', () => this.exportWrongQuestions());

                const navReviewBtn = document.getElementById('nav-review-mode');
                if (navReviewBtn) {
                     navReviewBtn.addEventListener('click', () => {
                         if (!this.questions.length) {
                            alert('è¯·å…ˆåŠ è½½é¢˜åº“ï¼');
                            document.getElementById('csv-upload-input').click();
                            this.closeFloatingNav();
                            return;
                        }
                        this.switchMode('wrong');
                        this.closeFloatingNav();
                    });
                }

                // Clickable stat cards
                const completedCard = document.getElementById('completed-questions-card');
                if (completedCard) completedCard.addEventListener('click', () => { this.showCompletedQuestions(); });
                
                const correctCard = document.getElementById('correct-questions-card');
                if (correctCard) correctCard.addEventListener('click', () => { this.showCorrectQuestions(); });

                const wrongCard = document.getElementById('wrong-questions-card');
                if (wrongCard) wrongCard.addEventListener('click', () => { this.switchMode('wrong'); });


                this.bindFloatingNavEvents(); 
                this.bindMobileNavEvents();
                this.bindScrollToTopEvents();
            }

            // æ˜¾ç¤ºå·²å®Œæˆçš„é¢˜ç›®
            showCompletedQuestions() {
                if (!this.questions.length) { alert('è¯·å…ˆåŠ è½½é¢˜åº“ï¼'); return; }
                if (this.statistics.completed === 0) { alert('å½“å‰æ²¡æœ‰å·²å®Œæˆçš„é¢˜ç›®ã€‚'); return; }
                
                this.currentMode = 'completed';
                this.updateModeButtonsUI();
                this.filterQuestions();
                this.currentQuestionIndex = 0;
                this.renderQuestion();
                this.updateNavigation();
            }

            // æ˜¾ç¤ºç­”å¯¹çš„é¢˜ç›®
            showCorrectQuestions() {
                if (!this.questions.length) { alert('è¯·å…ˆåŠ è½½é¢˜åº“ï¼'); return; }
                if (this.statistics.correct === 0) { alert('å½“å‰æ²¡æœ‰ç­”å¯¹çš„é¢˜ç›®ã€‚'); return; }

                this.currentMode = 'correct';
                this.updateModeButtonsUI();
                this.filterQuestions();
                this.currentQuestionIndex = 0;
                this.renderQuestion();
                this.updateNavigation();
            }

            updateModeButtonsUI() {
                 // Update main mode buttons
                document.querySelectorAll('.mode-selector .mode-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === this.currentMode);
                });
                // Update nav panel mode buttons
                document.querySelectorAll('#nav-mode-list .nav-item').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === this.currentMode);
                });
            }


            // è®¾ç½®é”®ç›˜å¿«æ·é”®
            setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
                        return;
                    }

                    switch(e.key.toUpperCase()) { // Use toUpperCase for A-D keys
                        case 'ARROWUP':
                            e.preventDefault();
                            this.previousQuestion();
                            break;
                        case 'ARROWDOWN':
                            e.preventDefault();
                            this.nextQuestion();
                            break;
                        case 'ENTER':
                            e.preventDefault();
                            this.submitCurrentAnswer();
                            break;
                        case ' ': // Spacebar
                            e.preventDefault();
                            this.showCurrentExplanation();
                            break;
                        case '1': this.selectOption(0); break;
                        case '2': this.selectOption(1); break;
                        case '3': this.selectOption(2); break;
                        case '4': this.selectOption(3); break;
                        case 'A': this.selectOptionByKey('A'); break;
                        case 'B': this.selectOptionByKey('B'); break;
                        case 'C': this.selectOptionByKey('C'); break;
                        case 'D': this.selectOptionByKey('D'); break;
                        case 'E': this.selectOptionByKey('E'); break; // For X type with more options
                        case 'F': this.selectOptionByKey('F'); break;
                        case 'G': this.selectOptionByKey('G'); break;
                        case 'H':
                            e.preventDefault();
                            this.toggleKeyboardHints();
                            break;
                    }
                });

                setTimeout(() => {
                    this.showKeyboardHints();
                }, 2000);
            }

            // é€‰æ‹©é€‰é¡¹ï¼ˆé€šè¿‡ç´¢å¼•ï¼‰
            selectOption(index) {
                const currentQuestionCard = document.querySelector(`.question-card[data-question-id="${this.filteredQuestions[this.currentQuestionIndex]?.id}"]`);
                if (!currentQuestionCard) return;

                const options = currentQuestionCard.querySelectorAll('.option input');
                if (options[index] && !options[index].disabled) {
                    if (options[index].type === 'radio') {
                        options[index].checked = true;
                    } else {
                        options[index].checked = !options[index].checked;
                    }
                    options[index].dispatchEvent(new Event('change', { bubbles: true }));
                }
            }

            // é€‰æ‹©é€‰é¡¹ï¼ˆé€šè¿‡é”®å€¼ï¼‰
            selectOptionByKey(key) {
                const currentQuestionCard = document.querySelector(`.question-card[data-question-id="${this.filteredQuestions[this.currentQuestionIndex]?.id}"]`);
                if (!currentQuestionCard) return;

                const option = currentQuestionCard.querySelector(`.option input[value="${key}"]`);
                if (option && !option.disabled) {
                    if (option.type === 'radio') {
                        option.checked = true;
                    } else {
                        option.checked = !option.checked;
                    }
                    option.dispatchEvent(new Event('change', { bubbles: true }));
                }
            }

            // æäº¤å½“å‰ç­”æ¡ˆ
            submitCurrentAnswer() {
                const currentQuestionCard = document.querySelector(`.question-card[data-question-id="${this.filteredQuestions[this.currentQuestionIndex]?.id}"]`);
                if (!currentQuestionCard) return;
                const submitBtn = currentQuestionCard.querySelector('#submit-answer');
                if (submitBtn && !submitBtn.disabled) {
                    submitBtn.click();
                }
            }

            // æ˜¾ç¤ºå½“å‰é¢˜ç›®è§£æ
            showCurrentExplanation() {
                const currentQuestionCard = document.querySelector(`.question-card[data-question-id="${this.filteredQuestions[this.currentQuestionIndex]?.id}"]`);
                if (!currentQuestionCard) return;
                const showExplanationBtn = currentQuestionCard.querySelector('#show-explanation');
                if (showExplanationBtn) {
                    showExplanationBtn.click();
                }
            }

            // åˆ‡æ¢é”®ç›˜æç¤ºæ˜¾ç¤º
            toggleKeyboardHints() {
                const hints = document.getElementById('keyboard-hints');
                if (this.keyboardHintsVisible) {
                    hints.classList.remove('show');
                    this.keyboardHintsVisible = false;
                } else {
                    hints.classList.add('show');
                    this.keyboardHintsVisible = true;
                }
            }

            // æ˜¾ç¤ºé”®ç›˜æç¤º
            showKeyboardHints() {
                const hints = document.getElementById('keyboard-hints');
                hints.classList.add('show');
                this.keyboardHintsVisible = true;
                
                setTimeout(() => {
                    hints.classList.remove('show');
                    this.keyboardHintsVisible = false;
                }, 3000);
            }

            // å…³é—­æµ®åŠ¨å¯¼èˆª
            closeFloatingNav() {
                const floatingNav = document.getElementById('floating-nav');
                if (floatingNav && floatingNav.classList.contains('expanded')) {
                    floatingNav.classList.remove('expanded');
                    floatingNav.classList.add('collapsed');
                }
                this.closeMobileNav();
            }

            // å¯¼å‡ºé”™é¢˜åŠŸèƒ½
            exportWrongQuestions() {
                const wrongQuestions = this.questions.filter(q => {
                    const answer = this.userAnswers[q.id];
                    return answer && !answer.isCorrect;
                });

                if (wrongQuestions.length === 0) {
                    alert('å½“å‰æ²¡æœ‰é”™é¢˜å¯å¯¼å‡ºï¼');
                    return;
                }

                const csvContent = this.generateWrongQuestionsCSV(wrongQuestions);
                
                const blob = new Blob(["\uFEFF" + csvContent], { type: 'text/csv;charset=utf-8;' }); // Add BOM for Excel
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', `é”™é¢˜é›†_${new Date().toISOString().split('T')[0]}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                alert(`å·²å¯¼å‡º ${wrongQuestions.length} é“é”™é¢˜ï¼`);
            }

            // ç”Ÿæˆé”™é¢˜CSVå†…å®¹
            generateWrongQuestionsCSV(wrongQuestions) {
                const headers = ['è¯•å·åç§°', 'å¹´ä»½', 'æœˆæ—¥', 'çœ', 'å¸‚', 'å¿/åŒº', 'é¢˜å‹æ ‡ç­¾', 'åŸå§‹é¢˜å·', 'é¢˜å¹²', 'ç­”æ¡ˆ', 'ä½ çš„ç­”æ¡ˆ', 'è§£æ', 'çŸ¥è¯†æ ‘1', 'çŸ¥è¯†æ ‘2', 'çŸ¥è¯†æ ‘3', 'çŸ¥è¯†æ ‘4', 'çŸ¥è¯†æ ‘5'];
                let csvString = headers.map(h => `"${h.replace(/"/g, '""')}"`).join(',') + '\n'; // Quote headers

                wrongQuestions.forEach(q => {
                    const userAnswer = this.userAnswers[q.id];
                    
                    // Reconstruct the original 'é¢˜å¹²' format for export if options were split
                    let originalStemWithOptions = q.question;
                    if (q.type !== 'judge' && q.options.length > 0) {
                        const optionsString = q.options.map(opt => `\n${opt.key}.${opt.text}`).join('');
                        originalStemWithOptions += optionsString;
                    }

                    const rowValues = [
                        q.originalData?.paperName || '',
                        q.originalData?.year || '',
                        q.originalData?.date || '',
                        q.originalData?.çœ || '', // Add these if they exist in originalData
                        q.originalData?.å¸‚ || '',
                        q.originalData?.['å¿/åŒº'] || '',
                        this.getQuestionTypeOriginalLabel(q.type, q.originalData?.é¢˜å‹æ ‡ç­¾),
                        q.id,
                        originalStemWithOptions, // Use reconstructed stem
                        Array.isArray(q.correctAnswer) ? q.correctAnswer.join('') : q.correctAnswer,
                        Array.isArray(userAnswer.answer) ? userAnswer.answer.join('') : userAnswer.answer,
                        q.explanation,
                        q.originalData?.çŸ¥è¯†æ ‘1 || '',
                        q.originalData?.çŸ¥è¯†æ ‘2 || '',
                        q.originalData?.çŸ¥è¯†æ ‘3 || '',
                        q.originalData?.çŸ¥è¯†æ ‘4 || '',
                        q.originalData?.çŸ¥è¯†æ ‘5 || ''
                    ];
                    
                    csvString += rowValues.map(val => `"${String(val || '').replace(/"/g, '""')}"`).join(',') + '\n';
                });

                return csvString;
            }

            getQuestionTypeOriginalLabel(internalType, originalLabel) {
                if (originalLabel) return originalLabel; // Prefer original if available
                if (internalType === 'single') return 'A1'; // Default for single
                if (internalType === 'multiple') return 'X';
                if (internalType === 'judge') return 'E';
                return '';
            }
            
            bindFloatingNavEvents() {
                const floatingNav = document.getElementById('floating-nav');
                const navTrigger = document.getElementById('nav-trigger');
                const navPanel = document.getElementById('nav-panel');

                if (navTrigger && floatingNav) {
                    navTrigger.addEventListener('click', (event) => {
                        event.stopPropagation();
                        floatingNav.classList.toggle('expanded');
                        floatingNav.classList.toggle('collapsed');
                    });
                }

                // Close nav panel when clicking outside
                document.addEventListener('click', (event) => {
                    if (floatingNav && navPanel && floatingNav.classList.contains('expanded')) {
                        // Check if the click is outside the navPanel and not on the trigger
                        if (!navPanel.contains(event.target) && event.target !== navTrigger && !navTrigger.contains(event.target)) {
                            floatingNav.classList.remove('expanded');
                            floatingNav.classList.add('collapsed');
                        }
                    }
                });
                
                // Knowledge tree toggle event delegation
                navPanel.addEventListener('click', (e) => {
                    const toggleBtn = e.target.closest('.knowledge-tree-toggle');
                    if (toggleBtn) {
                        e.preventDefault();
                        e.stopPropagation();
                        const nodeName = toggleBtn.dataset.nodeName;
                        const level = parseInt(toggleBtn.dataset.level);
                        this.toggleKnowledgeNode(nodeName, level);
                    }

                    const navItem = e.target.closest('.nav-item[data-knowledge-node]');
                    if (navItem && !e.target.closest('.knowledge-tree-toggle')) {
                        e.preventDefault();
                        const nodeData = JSON.parse(navItem.dataset.knowledgeNode);
                        this.addFilter(nodeData.level.toString(), nodeData.name);
                        this.closeFloatingNav();
                    }
                });
                
                // Subject nav event delegation
                const dynamicSubjectList = document.getElementById('dynamic-subject-list');
                if (dynamicSubjectList) {
                    dynamicSubjectList.addEventListener('click', (e) => {
                        const link = e.target.closest('.nav-item[data-subject-nav]');
                        if (link) {
                            e.preventDefault();
                            if (!this.questions.length) {
                                alert('è¯·å…ˆåŠ è½½é¢˜åº“ï¼');
                                this.closeFloatingNav();
                                document.getElementById('csv-upload-input').click();
                                return;
                            }
                            const subject = link.dataset.subjectNav;
                            this.jumpToSubject(subject);
                            this.closeFloatingNav();
                        }
                    });
                }

                // Type nav event delegation
                const dynamicTypeList = document.getElementById('dynamic-type-list');
                if (dynamicTypeList) {
                    dynamicTypeList.addEventListener('click', (e) => {
                        const link = e.target.closest('.nav-item[data-type-nav]');
                        if (link) {
                            e.preventDefault();
                            if (!this.questions.length) {
                                alert('è¯·å…ˆåŠ è½½é¢˜åº“ï¼');
                                this.closeFloatingNav();
                                document.getElementById('csv-upload-input').click();
                                return;
                            }
                            const type = link.dataset.typeNav;
                            this.jumpToType(type);
                            this.closeFloatingNav();
                        }
                    });
                }
            }

             bindMobileNavEvents() {
                const mobileNavToggle = document.getElementById('mobile-nav-toggle');
                const navPanel = document.getElementById('nav-panel');
                const mobileOverlay = document.getElementById('mobile-overlay');

                if (mobileNavToggle && navPanel && mobileOverlay) {
                    mobileNavToggle.addEventListener('click', (event) => {
                        event.stopPropagation();
                        navPanel.classList.toggle('mobile-open');
                        mobileOverlay.style.display = navPanel.classList.contains('mobile-open') ? 'block' : 'none';
                        const icon = mobileNavToggle.querySelector('i');
                        icon.className = navPanel.classList.contains('mobile-open') ? 'fas fa-times' : 'fas fa-bars';
                    });

                    mobileOverlay.addEventListener('click', () => {
                        this.closeMobileNav();
                    });
                }
            }

            closeMobileNav() {
                const navPanel = document.getElementById('nav-panel');
                const mobileOverlay = document.getElementById('mobile-overlay');
                const mobileNavToggle = document.getElementById('mobile-nav-toggle');
                if (navPanel) navPanel.classList.remove('mobile-open');
                if (mobileOverlay) mobileOverlay.style.display = 'none';
                if (mobileNavToggle) mobileNavToggle.querySelector('i').className = 'fas fa-bars';
            }

            bindScrollToTopEvents() {
                const scrollToTopBtn = document.getElementById('scrollToTopBtn');
                if (!scrollToTopBtn) return;
                window.addEventListener('scroll', () => {
                    if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
                        scrollToTopBtn.style.display = "flex";
                    } else {
                        scrollToTopBtn.style.display = "none";
                    }
                });
                scrollToTopBtn.addEventListener('click', () => {
                    window.scrollTo({top: 0, behavior: 'smooth'});
                });
            }

            switchMode(mode) {
                this.currentMode = mode;
                this.updateModeButtonsUI(); // Centralized UI update for mode buttons
                
                this.filterQuestions();
                this.currentQuestionIndex = 0;
                this.renderQuestion();
                this.updateNavigation();
            }

            filterQuestions() {
                let filtered = [...this.questions];
                
                // Apply knowledge tree filters first if in 'knowledge' mode or if any filters are active
                if (this.currentMode === 'knowledge' || this.activeFilters.length > 0) {
                    if (this.activeFilters.length > 0) {
                         filtered = filtered.filter(q => {
                            return this.activeFilters.some(filter => {
                                const level1 = q.originalData?.çŸ¥è¯†æ ‘1 || q.subject || 'ç»¼åˆ';
                                const level2 = q.originalData?.çŸ¥è¯†æ ‘2 || '';
                                const level3 = q.originalData?.çŸ¥è¯†æ ‘3 || '';
                                
                                if (filter.level === '1') return level1 === filter.point;
                                if (filter.level === '2') return level2 === filter.point;
                                if (filter.level === '3') return level3 === filter.point;
                                return false;
                            });
                        });
                    } else if (this.currentMode === 'knowledge') {
                         // If in knowledge mode but no filter selected, show no questions or a prompt
                        filtered = []; 
                    }
                }
                
                // Then, apply mode-specific filtering on the (potentially already filtered) list
                switch (this.currentMode) {
                    case 'random':
                        filtered = filtered.filter(q => !this.userAnswers[q.id]);
                        filtered = filtered.sort(() => Math.random() - 0.5);
                        break;
                    case 'sequential':
                        filtered = filtered.filter(q => !this.userAnswers[q.id]);
                        break;
                    case 'wrong':
                        filtered = this.questions.filter(q => { // Filter from original questions for wrong mode
                            const answer = this.userAnswers[q.id];
                            return answer && !answer.isCorrect;
                        });
                        if (filtered.length === 0 && this.questions.length > 0) { 
                           // Alert moved to renderQuestion for better UX
                        }
                        break;
                    case 'completed':
                        filtered = this.questions.filter(q => this.userAnswers[q.id]); // Filter from original
                        break;
                    case 'correct':
                         filtered = this.questions.filter(q => { // Filter from original
                            const answer = this.userAnswers[q.id];
                            return answer && answer.isCorrect;
                        });
                        break;
                    case 'knowledge':
                        // Already handled above. If no activeFilters, filtered will be empty.
                        // If activeFilters exist, filtered will be based on them.
                        // Then, filter out answered questions for practice.
                        filtered = filtered.filter(q => !this.userAnswers[q.id]);
                        break;
                    case 'subject':
                        const activeSubjectLink = document.querySelector('#dynamic-subject-list .nav-item.active[data-subject-nav]');
                        if (activeSubjectLink) {
                            const subjectName = activeSubjectLink.dataset.subjectNav;
                            filtered = this.questions.filter(q => (q.subject || 'ç»¼åˆ') === subjectName);
                        } else {
                             // If no subject explicitly selected via nav, could show all or a prompt.
                             // For now, assume it's handled by switchMode if called from nav.
                        }
                        filtered = filtered.filter(q => !this.userAnswers[q.id]); // Practice un-answered in subject
                        break;
                    case 'type':
                        const activeTypeLink = document.querySelector('#dynamic-type-list .nav-item.active[data-type-nav]');
                        if (activeTypeLink) {
                            const typeName = activeTypeLink.dataset.typeNav;
                            filtered = this.questions.filter(q => q.type === typeName);
                        }
                        filtered = filtered.filter(q => !this.userAnswers[q.id]); // Practice un-answered in type
                        break;
                }
                
                this.filteredQuestions = filtered;
                
                // Fallback if filtered list is empty but shouldn't be (e.g. not wrong mode and all questions answered)
                if (this.filteredQuestions.length === 0 && 
                    this.questions.length > 0 && 
                    (this.currentMode === 'sequential' || this.currentMode === 'random' || this.currentMode === 'knowledge' || this.currentMode === 'subject' || this.currentMode === 'type' ) &&
                    this.questions.every(q => this.userAnswers[q.id])) {
                    // All questions are answered in this mode/filter, so allow review
                    // This part needs careful consideration: what to show if all done?
                    // For now, let renderQuestion handle the empty message.
                }
            }

            jumpToSubject(subjectName) {
                this.currentMode = 'subject'; 
                this.updateModeButtonsUI();

                document.querySelectorAll('#dynamic-subject-list .nav-item[data-subject-nav]').forEach(item => item.classList.remove('active'));
                const navLink = document.querySelector(`#dynamic-subject-list .nav-item[data-subject-nav="${subjectName}"]`);
                if (navLink) navLink.classList.add('active');

                this.activeFilters = []; // Clear knowledge tree filters when switching to subject mode
                this.updateFilterTags();

                this.filterQuestions(); // filterQuestions will use currentMode 'subject'
                this.currentQuestionIndex = 0;
                
                if (this.filteredQuestions.length === 0 && this.questions.length > 0) {
                    // Message handled in renderQuestion
                }
                this.renderQuestion();
                this.updateNavigation();
            }

            jumpToType(typeName) {
                this.currentMode = 'type'; 
                this.updateModeButtonsUI();

                document.querySelectorAll('#dynamic-type-list .nav-item[data-type-nav]').forEach(item => item.classList.remove('active'));
                const navLink = document.querySelector(`#dynamic-type-list .nav-item[data-type-nav="${typeName}"]`);
                if (navLink) navLink.classList.add('active');
                
                this.activeFilters = []; // Clear knowledge tree filters
                this.updateFilterTags();

                this.filterQuestions(); // filterQuestions will use currentMode 'type'
                this.currentQuestionIndex = 0;

                if (this.filteredQuestions.length === 0 && this.questions.length > 0) {
                    // Message handled in renderQuestion
                }
                this.renderQuestion();
                this.updateNavigation();
            }

            renderQuestion() {
                const container = document.getElementById('question-container');
                if (!this.filteredQuestions || this.filteredQuestions.length === 0) {
                    let message = 'è¯·å…ˆåŠ è½½é¢˜åº“å¼€å§‹ç»ƒä¹ ã€‚';
                    if (this.questions.length > 0) { 
                         message = 'å½“å‰æ¨¡å¼/ç­›é€‰æ¡ä»¶ä¸‹æ²¡æœ‰é¢˜ç›®ã€‚';
                         if (this.currentMode === 'wrong') message = 'å¤ªæ£’äº†ï¼å½“å‰æ²¡æœ‰é”™é¢˜ã€‚';
                         else if (this.currentMode === 'knowledge' && this.activeFilters.length === 0) message = 'è¯·å…ˆä»å·¦ä¾§å¯¼èˆªé€‰æ‹©çŸ¥è¯†ç‚¹è¿›è¡Œç»ƒä¹ ã€‚';
                         else if (this.currentMode === 'knowledge' && this.activeFilters.length > 0) message = 'è¯¥çŸ¥è¯†ç‚¹ä¸‹å·²æ— æœªç»ƒä¹ é¢˜ç›®ï¼Œæˆ–å·²å…¨éƒ¨å®Œæˆã€‚';
                         else if (this.currentMode === 'completed') message = 'å½“å‰æ²¡æœ‰å·²å®Œæˆçš„é¢˜ç›®ã€‚';
                         else if (this.currentMode === 'correct') message = 'å½“å‰æ²¡æœ‰ç­”å¯¹çš„é¢˜ç›®ã€‚';
                         else if (this.currentMode === 'subject' || this.currentMode === 'type') message = 'è¯¥åˆ†ç±»ä¸‹å·²æ— æœªç»ƒä¹ é¢˜ç›®ï¼Œæˆ–å·²å…¨éƒ¨å®Œæˆã€‚';
                         else if (this.currentMode === 'sequential' || this.currentMode === 'random') {
                             if (this.questions.every(q => this.userAnswers[q.id])) {
                                message = 'æ­å–œï¼æ‰€æœ‰é¢˜ç›®éƒ½å·²å®Œæˆã€‚å¯ä»¥å°è¯•é”™é¢˜é‡åšæˆ–é‡ç½®è¿›åº¦ã€‚';
                             } else {
                                message = 'å½“å‰æ¨¡å¼ä¸‹å·²æ— æœªç»ƒä¹ é¢˜ç›®ã€‚';
                             }
                         }
                    }
                    container.innerHTML = `
                        <div id="trigger-upload-area" class="text-center text-gray-500 p-8 border-2 border-dashed border-gray-300 rounded-lg">
                            <i class="fas ${this.questions.length ? 'fa-book-reader' : 'fa-book-open'} fa-3x text-gray-400 mb-4"></i>
                            <p>${message}</p>
                            ${!this.questions.length ? '<p class="mt-2 text-sm">ç‚¹å‡»æ­¤å¤„æˆ–é€šè¿‡å¯¼èˆªæ /é¡µè„šé“¾æ¥ä¸Šä¼ æ‚¨çš„CSVé¢˜åº“æ–‡ä»¶ã€‚</p>' : ''}
                        </div>`;
                    
                    if (!this.questions.length) {
                        const triggerUpload = document.getElementById('trigger-upload-area');
                        if(triggerUpload) {
                            triggerUpload.onclick = () => document.getElementById('csv-upload-input').click();
                        }
                    }

                    this.updateQuestionCounter(); 
                    this.updateNavigation(); 
                    return;
                }
                const question = this.filteredQuestions[this.currentQuestionIndex];
                 if (!question) { 
                    container.innerHTML = '<div class="text-center text-gray-500">é¢˜ç›®åŠ è½½é”™è¯¯ã€‚</div>';
                    return;
                }

                const userAnswer = this.userAnswers[question.id];
                // In 'wrong', 'completed', 'correct' modes, we are reviewing, so isAnsweredForDisplay is true.
                // For other modes, it's true if an answer exists.
                let isAnsweredForDisplay = !!userAnswer; 
                let allowReanswer = (this.currentMode === 'wrong' || this.currentMode === 'completed' || this.currentMode === 'correct');

                let optionsHtml = '';
                if (question.type === 'judge') {
                     optionsHtml = question.options.map(option => `
                        <label class="option ${this.getOptionClass(option.key, question, userAnswer, isAnsweredForDisplay, allowReanswer)}" 
                               data-value="${option.key}">
                            <input type="radio" name="option-${question.id}" value="${option.key}" 
                                   ${userAnswer && userAnswer.answer === option.key ? 'checked' : ''} 
                                   ${(isAnsweredForDisplay && !allowReanswer) ? 'disabled' : ''}>
                            <span class="option-label">${option.key}</span>
                            <span class="option-text">${option.text}</span>
                        </label>
                    `).join('');
                } else if (question.type === 'multiple') {
                    optionsHtml = question.options.map(option => `
                        <label class="option ${this.getOptionClass(option.key, question, userAnswer, isAnsweredForDisplay, allowReanswer)}" 
                               data-value="${option.key}">
                            <input type="checkbox" name="option-${question.id}-${option.key}" value="${option.key}"
                                   ${userAnswer && userAnswer.answer && Array.isArray(userAnswer.answer) && userAnswer.answer.includes(option.key) ? 'checked' : ''}
                                   ${(isAnsweredForDisplay && !allowReanswer) ? 'disabled' : ''}>
                            <span class="option-label">${option.key}</span>
                            <span class="option-text">${option.text}</span>
                        </label>
                    `).join('');
                } else { // single
                    optionsHtml = question.options.map(option => `
                        <label class="option ${this.getOptionClass(option.key, question, userAnswer, isAnsweredForDisplay, allowReanswer)}" 
                               data-value="${option.key}">
                            <input type="radio" name="option-${question.id}" value="${option.key}"
                                   ${userAnswer && userAnswer.answer === option.key ? 'checked' : ''}
                                   ${(isAnsweredForDisplay && !allowReanswer) ? 'disabled' : ''}>
                            <span class="option-label">${option.key}</span>
                            <span class="option-text">${option.text}</span>
                        </label>
                    `).join('');
                }

                container.innerHTML = `
                    <div class="question-card" data-question-id="${question.id}">
                        <div class="question-header">
                            <span class="question-type-badge">${this.getQuestionTypeText(question.type)}</span>
                            <span class="question-number">ç¬¬ ${this.currentQuestionIndex + 1} é¢˜ (ID: ${question.id})</span>
                        </div>
                        
                        <div class="question-content">
                            <p class="question-text">${question.question}</p>
                            <div class="options-container">${optionsHtml}</div>
                        </div>
                        
                        <div class="question-actions">
                            ${ (!isAnsweredForDisplay || allowReanswer) ? `
                                <button class="btn btn-primary" id="submit-answer">
                                    <i class="fas fa-check"></i> æäº¤ç­”æ¡ˆ
                                </button>
                            ` : ''}
                            <button class="btn btn-secondary" id="show-explanation">
                                <i class="fas fa-lightbulb"></i> æŸ¥çœ‹è§£æ
                            </button>
                        </div>
                        
                        <div class="answer-explanation" id="explanation-${question.id}" style="${(isAnsweredForDisplay && !allowReanswer) ? 'display:block;' : 'display:none;'}">
                            <div class="correct-answer">
                                <h4>æ­£ç¡®ç­”æ¡ˆï¼š${Array.isArray(question.correctAnswer) ? question.correctAnswer.join('') : question.correctAnswer}</h4>
                                ${userAnswer && userAnswer.answer !== undefined ? `<h5>ä½ çš„ç­”æ¡ˆï¼š${Array.isArray(userAnswer.answer) ? userAnswer.answer.join('') : userAnswer.answer} ${userAnswer.isCorrect ? "<span class='text-green-500 font-semibold'> (æ­£ç¡®)</span>" : "<span class='text-red-500 font-semibold'> (é”™è¯¯)</span>"}</h5>` : ''}
                            </div>
                            <div class="explanation-content">
                                <h5>è§£æï¼š</h5>
                                <p>${question.explanation}</p>
                            </div>
                            <div class="knowledge-points">
                                <h6>ç›¸å…³è€ƒç‚¹ï¼š</h6>
                                ${question.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
                            </div>
                        </div>
                    </div>
                `;

                this.bindQuestionEvents(question);
                this.updateQuestionCounter();

                // If reviewing an already answered question (and not in a re-answer mode), show explanation and style options.
                if (isAnsweredForDisplay && !allowReanswer) {
                    this.showExplanation(question.id, true); // silent = true to avoid animation
                    this.styleAnsweredOptions(question, userAnswer, false); // isReanswering = false
                } else if (allowReanswer && isAnsweredForDisplay) {
                     // In re-answer modes, pre-fill if an answer exists but don't style correct/wrong yet.
                     // This is mostly handled by the 'checked' attribute in the HTML generation.
                     // We might need to re-apply 'selected' class based on pre-filled inputs.
                     const questionCard = document.querySelector(`.question-card[data-question-id="${question.id}"]`);
                     if (questionCard) {
                         questionCard.querySelectorAll('.option input:checked').forEach(inputEl => {
                            inputEl.closest('.option').classList.add('selected');
                         });
                     }
                     this.showExplanation(question.id, true); // Show explanation directly in review modes
                     this.styleAnsweredOptions(question, userAnswer, true); // isReanswering = true
                }
            }
            
            bindQuestionEvents(question) {
                const questionCard = document.querySelector(`.question-card[data-question-id="${question.id}"]`);
                if (!questionCard) return;
                
                const isAnswered = !!this.userAnswers[question.id];
                const allowReanswer = (this.currentMode === 'wrong' || this.currentMode === 'completed' || this.currentMode === 'correct');

                questionCard.querySelectorAll('.option input').forEach(inputEl => {
                    // If already answered and not in a re-answer mode, disable inputs
                    if (isAnswered && !allowReanswer) {
                        inputEl.disabled = true;
                    }

                    inputEl.addEventListener('change', () => {
                        // If already answered and not in re-answer mode, do nothing on change
                        if (isAnswered && !allowReanswer) return;

                        // Clear previous correct/wrong styling if re-answering
                        if (allowReanswer) {
                            questionCard.querySelectorAll('.option').forEach(opt => {
                                opt.classList.remove('correct', 'wrong', 'selected');
                                // opt.querySelector('input').disabled = false; // Ensure inputs are enabled for re-answer
                            });
                        }

                        if (question.type !== 'multiple') { 
                            questionCard.querySelectorAll('.option').forEach(opt => opt.classList.remove('selected'));
                            inputEl.closest('.option').classList.add('selected');
                        } else { 
                            inputEl.closest('.option').classList.toggle('selected', inputEl.checked);
                        }
                        
                        const submitBtn = questionCard.querySelector('#submit-answer');
                        if (submitBtn) {
                            const anySelected = !!questionCard.querySelector('.option input:checked');
                            submitBtn.disabled = !anySelected;
                        }
                    });
                });
                
                questionCard.querySelectorAll('.option').forEach(optionLabel => {
                    optionLabel.addEventListener('click', (e) => {
                        if (e.target.tagName === 'INPUT' || (isAnswered && !allowReanswer)) return;
                        
                        const input = optionLabel.querySelector('input');
                        if (input && !input.disabled) { // Check if input is not disabled
                            if (question.type === 'multiple') {
                                input.checked = !input.checked;
                            } else {
                                input.checked = true;
                            }
                            input.dispatchEvent(new Event('change', { bubbles: true }));
                        }
                    });
                });

                const submitBtn = questionCard.querySelector('#submit-answer');
                if (submitBtn) {
                    // Initial state of submit button
                    const anySelectedInitially = !!questionCard.querySelector('.option input:checked');
                    submitBtn.disabled = !anySelectedInitially;
                    
                    if (isAnswered && !allowReanswer) { // Hide if already answered and not re-answering
                        submitBtn.style.display = 'none';
                    }

                    submitBtn.addEventListener('click', () => {
                        let selectedAnswer;
                        if (question.type === 'multiple') {
                            selectedAnswer = Array.from(questionCard.querySelectorAll('.option input:checked'))
                                                .map(cb => cb.value)
                                                .sort(); 
                        } else {
                            const selectedRadio = questionCard.querySelector('.option input:checked');
                            selectedAnswer = selectedRadio ? selectedRadio.value : null;
                        }

                        if (selectedAnswer !== null && ( (typeof selectedAnswer === 'string' && selectedAnswer.length > 0) || (Array.isArray(selectedAnswer) && selectedAnswer.length > 0) ) ) {
                             this.submitAnswer(question, selectedAnswer);
                        } else {
                            alert('è¯·é€‰æ‹©ä¸€ä¸ªç­”æ¡ˆï¼');
                        }
                    });
                }

                const showExplanationBtn = questionCard.querySelector('#show-explanation');
                if (showExplanationBtn) {
                    showExplanationBtn.addEventListener('click', () => this.showExplanation(question.id));
                }
            }

            submitAnswer(question, selectedAnswer) { 
                let isCorrect;
                let correctAnswerNormalized = Array.isArray(question.correctAnswer) ? 
                                              question.correctAnswer.map(String).sort().join('') : 
                                              String(question.correctAnswer);
                let selectedAnswerNormalized = Array.isArray(selectedAnswer) ? 
                                             selectedAnswer.map(String).sort().join('') : 
                                             String(selectedAnswer);

                isCorrect = selectedAnswerNormalized === correctAnswerNormalized;
                
                // If in 'wrong' mode and answer is now correct, mark it specially or remove from wrong list on next filter
                // For now, just update the answer
                this.userAnswers[question.id] = {
                    answer: selectedAnswer, 
                    isCorrect: isCorrect,
                    timestamp: Date.now()
                };
                
                this.styleAnsweredOptions(question, this.userAnswers[question.id], false); // Not re-answering after submit

                const submitBtn = document.querySelector(`.question-card[data-question-id="${question.id}"] #submit-answer`);
                if (submitBtn) submitBtn.style.display = 'none'; // Hide submit button after submission

                this.showExplanation(question.id);
                this.updateStatistics();
                this.saveProgress();
            }
            
            styleAnsweredOptions(question, userAnswer, isReanswering) {
                const questionCard = document.querySelector(`.question-card[data-question-id="${question.id}"]`);
                if (!questionCard) return;

                questionCard.querySelectorAll('.option').forEach(optionDiv => {
                    const inputEl = optionDiv.querySelector('input');
                    const optionKey = inputEl.value;
                    
                    if (!isReanswering) { // Disable inputs only if not in a re-answer scenario
                        inputEl.disabled = true; 
                        optionDiv.classList.add('disabled'); 
                    } else {
                        inputEl.disabled = false; // Ensure enabled if re-answering
                        optionDiv.classList.remove('disabled');
                    }

                    let isSelectedByUser = false;
                    if (question.type === 'multiple') {
                        isSelectedByUser = userAnswer.answer && Array.isArray(userAnswer.answer) && userAnswer.answer.includes(optionKey);
                    } else {
                        isSelectedByUser = userAnswer.answer === optionKey;
                    }

                    let isActuallyCorrect = false;
                     if (question.type === 'multiple') {
                        isActuallyCorrect = question.correctAnswer && Array.isArray(question.correctAnswer) && question.correctAnswer.includes(optionKey);
                    } else {
                        isActuallyCorrect = question.correctAnswer === optionKey;
                    }

                    // Clear previous styling before applying new ones, important for re-answer
                    optionDiv.classList.remove('correct', 'wrong', 'selected');

                    if (isActuallyCorrect) {
                        optionDiv.classList.add('correct');
                    }
                    if (isSelectedByUser && !isActuallyCorrect) {
                        optionDiv.classList.add('wrong');
                    }
                    if (isSelectedByUser) { // Always mark what user selected
                         optionDiv.classList.add('selected');
                    }
                });
            }

            showExplanation(questionId, silent = false) {
                const explanation = document.getElementById(`explanation-${questionId}`);
                if (explanation) {
                    explanation.style.display = 'block'; 
                    if (!silent) explanation.classList.add('show'); 
                }
                const userAnswer = this.userAnswers[questionId];
                if (userAnswer && explanation) {
                    const correctAnswerDiv = explanation.querySelector('.correct-answer');
                    if (correctAnswerDiv) {
                        let yourAnswerH5 = correctAnswerDiv.querySelector('h5');
                        if (!yourAnswerH5) {
                            yourAnswerH5 = document.createElement('h5');
                            correctAnswerDiv.appendChild(yourAnswerH5);
                        }
                        const userAnswerText = Array.isArray(userAnswer.answer) ? userAnswer.answer.join('') : userAnswer.answer;
                        const correctnessText = userAnswer.isCorrect ? "<span class='text-green-500 font-semibold'> (æ­£ç¡®)</span>" : "<span class='text-red-500 font-semibold'> (é”™è¯¯)</span>";
                        yourAnswerH5.innerHTML = `ä½ çš„ç­”æ¡ˆï¼š${userAnswerText} ${correctnessText}`;
                    }
                }
            }
            
            getOptionClass(optionKey, question, userAnswer, isAnsweredForDisplay, allowReanswer) {
                let classes = '';
                // If we are allowing re-answer, don't apply correct/wrong classes until submission
                if (allowReanswer && isAnsweredForDisplay) {
                    // For re-answer modes, we might pre-select but not pre-judge
                    if (question.type === 'multiple') {
                        if (userAnswer && userAnswer.answer && userAnswer.answer.includes(optionKey)) classes += ' selected';
                    } else {
                        if (userAnswer && userAnswer.answer === optionKey) classes += ' selected';
                    }
                    return classes;
                }

                if (!isAnsweredForDisplay || !userAnswer) return classes; 

                let isSelectedByUser = false;
                if (question.type === 'multiple') {
                    isSelectedByUser = userAnswer.answer && Array.isArray(userAnswer.answer) && userAnswer.answer.includes(optionKey);
                } else {
                    isSelectedByUser = userAnswer.answer === optionKey;
                }

                let isActuallyCorrect = false;
                 if (question.type === 'multiple') {
                    isActuallyCorrect = question.correctAnswer && Array.isArray(question.correctAnswer) && question.correctAnswer.includes(optionKey);
                } else {
                    isActuallyCorrect = question.correctAnswer === optionKey;
                }

                if (isActuallyCorrect) classes += ' correct';
                if (isSelectedByUser && !isActuallyCorrect) classes += ' wrong';
                if (isSelectedByUser) classes += ' selected'; // Keep selected style for what user chose
                if (isAnsweredForDisplay) classes += ' disabled'; 
                
                return classes;
            }

            getQuestionTypeText(type) {
                // Map internal type to display text
                const typeMap = { 
                    'single': 'å•é€‰é¢˜', 
                    'multiple': 'å¤šé€‰é¢˜', 
                    'judge': 'åˆ¤æ–­é¢˜'
                };
                return typeMap[type] || 'æœªçŸ¥é¢˜å‹';
            }
            
            previousQuestion() {
                if (this.currentQuestionIndex > 0) {
                    this.currentQuestionIndex--;
                    this.renderQuestion();
                    this.updateNavigation();
                }
            }

            nextQuestion() {
                if (this.filteredQuestions && this.currentQuestionIndex < this.filteredQuestions.length - 1) {
                    this.currentQuestionIndex++;
                    this.renderQuestion();
                    this.updateNavigation();
                }
            }

            updateNavigation() {
                const prevBtn = document.getElementById('prev-btn');
                const nextBtn = document.getElementById('next-btn');
                if (!prevBtn || !nextBtn) return;

                const hasQuestions = this.filteredQuestions && this.filteredQuestions.length > 0;
                prevBtn.disabled = !hasQuestions || this.currentQuestionIndex === 0;
                nextBtn.disabled = !hasQuestions || this.currentQuestionIndex === this.filteredQuestions.length - 1;
            }

            updateQuestionCounter() {
                const counter = document.getElementById('question-counter');
                if (counter) {
                     counter.textContent = (this.filteredQuestions && this.filteredQuestions.length > 0) ?
                                     `${this.currentQuestionIndex + 1} / ${this.filteredQuestions.length}` :
                                     '0 / 0';
                }
            }

            updateStatistics() {
                const answeredQuestionIds = Object.keys(this.userAnswers);
                
                let completedCount = 0;
                let correctCount = 0;

                this.questions.forEach(q => {
                    if (this.userAnswers.hasOwnProperty(q.id)) {
                        completedCount++;
                        if (this.userAnswers[q.id].isCorrect) {
                            correctCount++;
                        }
                    }
                });
                
                const wrongCount = completedCount - correctCount;
                
                this.statistics = {
                    total: this.questions.length,
                    completed: completedCount,
                    correct: correctCount,
                    wrong: wrongCount,
                    accuracy: completedCount > 0 ? Math.round((correctCount / completedCount) * 100) : 0
                };

                // Update main stats display
                const totalEl = document.getElementById('total-questions');
                const completedEl = document.getElementById('completed-questions');
                const correctEl = document.getElementById('correct-questions');
                const wrongEl = document.getElementById('wrong-questions');
                const accuracyEl = document.getElementById('accuracy-rate');

                if(totalEl) totalEl.textContent = this.statistics.total;
                if(completedEl) completedEl.textContent = this.statistics.completed;
                if(correctEl) correctEl.textContent = this.statistics.correct;
                if(wrongEl) wrongEl.textContent = this.statistics.wrong;
                if(accuracyEl) accuracyEl.textContent = this.statistics.accuracy + '%';

                // Update nav panel stats
                const navCompletedEl = document.getElementById('nav-completed');
                const navAccuracyEl = document.getElementById('nav-accuracy');
                const navTotalEl = document.getElementById('nav-total');
                const navProgressFill = document.getElementById('nav-progress');

                if(navCompletedEl) navCompletedEl.textContent = this.statistics.completed;
                if(navAccuracyEl) navAccuracyEl.textContent = this.statistics.accuracy + '%';
                if(navTotalEl) navTotalEl.textContent = this.statistics.total;
                
                if (navProgressFill) {
                    const progressPercent = this.statistics.total > 0 ? Math.round((this.statistics.completed / this.statistics.total) * 100) : 0;
                    navProgressFill.style.width = progressPercent + '%';
                }

                this.updateSubjectProgressInNav();
                this.updateTypeProgressInNav();
                this.updateKnowledgeTreeStats(); // This will internally update node stats
                this.renderKnowledgeTree();      // Re-render tree with new stats
                this.renderKnowledgeDistribution();
            }
            
            updateSubjectProgressInNav() {
                const dynamicSubjectList = document.getElementById('dynamic-subject-list');
                if (!dynamicSubjectList) return;
                dynamicSubjectList.innerHTML = ''; 

                const subjectData = {};
                const subjectIcons = { 
                    "åŒ»å­¦åŸºç¡€çŸ¥è¯†": "ğŸ“š", "ç³»ç»Ÿè§£å‰–å­¦": "ğŸ«€", "ç”Ÿç†å­¦": "âš¡",
                    "è¯ç†å­¦": "ğŸ’Š", "ç—…ç†å­¦": "ğŸ”¬", "ä¸´åºŠä¸“ä¸šçŸ¥è¯†": "ğŸ©º", "å…¬å…±å«ç”ŸçŸ¥è¯†": "ğŸŒ",
                    "ç»¼åˆ": "ğŸ§©" // Default/fallback
                };

                this.questions.forEach(q => {
                    const subj = q.subject || 'ç»¼åˆ';
                    if (!subjectData[subj]) {
                        subjectData[subj] = { total: 0, answered: 0, correct: 0, icon: subjectIcons[subj] || 'ğŸ“–' }; 
                    }
                    subjectData[subj].total++;
                    if (this.userAnswers[q.id]) {
                        subjectData[subj].answered++;
                        if (this.userAnswers[q.id].isCorrect) {
                            subjectData[subj].correct++;
                        }
                    }
                });
                
                const sortedSubjects = Object.keys(subjectData).sort((a,b) => a.localeCompare(b));

                sortedSubjects.forEach(subjectName => {
                    const data = subjectData[subjectName];
                    const progress = data.total > 0 ? Math.round((data.answered / data.total) * 100) : 0;
                    const accuracy = data.answered > 0 ? Math.round((data.correct / data.answered) * 100) : 0;
                    
                    let weaknessLevel = '';
                    if (data.answered >= 3) {
                        if (accuracy < 40) weaknessLevel = 'high';
                        else if (accuracy < 60) weaknessLevel = 'medium';
                    }
                    
                    const navItem = document.createElement('a');
                    navItem.href = `#${subjectName.replace(/\s+/g, '-')}`; 
                    navItem.className = `nav-item`; // Removed knowledge-tree-level-1, subjects are distinct
                    navItem.dataset.subjectNav = subjectName;
                    navItem.innerHTML = `
                        <div class="nav-item-icon">${data.icon}</div>
                        <div class="nav-item-content">
                            <div class="nav-item-name">
                                ${subjectName}
                                ${weaknessLevel ? `<span class="weakness-indicator weakness-${weaknessLevel}">${accuracy}%</span>` : ''}
                            </div>
                            <div class="nav-item-progress">
                                <div class="mini-progress-bar"><div class="mini-progress-fill" style="width: ${progress}%;"></div></div>
                                <span class="nav-item-count">${data.total}é¢˜</span>
                            </div>
                        </div>`;
                    dynamicSubjectList.appendChild(navItem);
                });
            }

            updateTypeProgressInNav() {
                const dynamicTypeList = document.getElementById('dynamic-type-list');
                if (!dynamicTypeList) return;
                dynamicTypeList.innerHTML = ''; 

                const typeData = {};
                 const typeIcons = { 
                    "single": "1ï¸âƒ£",   // A1, A2, A3, A4, A3/A4
                    "multiple": "ğŸ”¢", // X
                    "judge": "âš–ï¸"     // E
                };

                this.questions.forEach(q => {
                    const type = q.type; // internal type: single, multiple, judge
                    if (!typeData[type]) {
                        typeData[type] = { total: 0, answered: 0, correct: 0, icon: typeIcons[type] || 'â“' }; 
                    }
                    typeData[type].total++;
                    if (this.userAnswers[q.id]) {
                        typeData[type].answered++;
                        if (this.userAnswers[q.id].isCorrect) {
                            typeData[type].correct++;
                        }
                    }
                });
                
                const sortedTypes = Object.keys(typeData).sort((a,b) => a.localeCompare(b));

                sortedTypes.forEach(typeName => { // typeName is 'single', 'multiple', 'judge'
                    const data = typeData[typeName];
                    const progress = data.total > 0 ? Math.round((data.answered / data.total) * 100) : 0;
                    const accuracy = data.answered > 0 ? Math.round((data.correct / data.answered) * 100) : 0;
                    
                    let weaknessLevel = '';
                    if (data.answered >= 3) {
                        if (accuracy < 40) weaknessLevel = 'high';
                        else if (accuracy < 60) weaknessLevel = 'medium';
                    }
                    
                    const navItem = document.createElement('a');
                    navItem.href = `#${typeName}`; 
                    navItem.className = 'nav-item';
                    navItem.dataset.typeNav = typeName; // Use internal type for dataset
                    navItem.innerHTML = `
                        <div class="nav-item-icon">${data.icon}</div>
                        <div class="nav-item-content">
                            <div class="nav-item-name">
                                ${this.getQuestionTypeText(typeName)}
                                ${weaknessLevel ? `<span class="weakness-indicator weakness-${weaknessLevel}">${accuracy}%</span>` : ''}
                            </div>
                            <div class="nav-item-progress">
                                <div class="mini-progress-bar"><div class="mini-progress-fill" style="width: ${progress}%;"></div></div>
                                <span class="nav-item-count">${data.total}é¢˜</span>
                            </div>
                        </div>`;
                    dynamicTypeList.appendChild(navItem);
                });
            }

            resetProgress() {
                if (confirm('ç¡®å®šè¦é‡ç½®å½“å‰é¢˜åº“çš„æ‰€æœ‰å­¦ä¹ è¿›åº¦å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚')) {
                    this.userAnswers = {};
                    this.activeFilters = [];
                    if (this.currentFileHash) {
                        localStorage.removeItem(this.LOCAL_STORAGE_KEY_PREFIX + this.currentFileHash);
                    }
                    this.updateFilterTags(); // Clear filter tags from UI
                    this.updateStatistics(); // Recalculate and update all stats to zero
                    
                    // Reset to default mode and re-filter/render
                    this.currentMode = 'sequential'; 
                    this.updateModeButtonsUI();
                    
                    if (this.questions.length > 0) {
                         this.currentQuestionIndex = 0; 
                         this.filterQuestions(); // Re-filter based on the new (empty) progress
                         this.renderQuestion();
                         this.updateNavigation();
                    } else {
                         this.renderInitialPrompt(); // If no questions loaded, show upload prompt
                         this.updateQuestionCounter();
                         this.updateNavigation(); 
                    }
                    alert('å­¦ä¹ è¿›åº¦å·²é‡ç½®ã€‚');
                }
            }
            
            renderInitialPrompt() {
                const container = document.getElementById('question-container');
                container.innerHTML = `
                    <div id="trigger-upload-area" class="text-center text-gray-500 p-8 border-2 border-dashed border-gray-300 rounded-lg">
                        <i class="fas fa-book-open fa-3x text-gray-400 mb-4"></i>
                        <p>æ¬¢è¿ä½¿ç”¨æç®€æ™ºèƒ½åˆ·é¢˜åº“ï¼</p>
                        <p class="mt-2 text-sm">ç‚¹å‡»æ­¤å¤„æˆ–é€šè¿‡å¯¼èˆªæ /é¡µè„šé“¾æ¥ä¸Šä¼ æ‚¨çš„CSVé¢˜åº“æ–‡ä»¶å¼€å§‹ç»ƒä¹ ã€‚</p>
                    </div>`;
                const triggerUpload = document.getElementById('trigger-upload-area');
                if(triggerUpload) {
                    triggerUpload.onclick = () => document.getElementById('csv-upload-input').click();
                }
                 this.updateFooterUploadTrigger(false);
            }
            
            updateFooterUploadTrigger(hasQuestions) {
                const footerTriggerContainer = document.getElementById('footer-upload-trigger-container');
                if (footerTriggerContainer) {
                    if (hasQuestions) {
                         footerTriggerContainer.innerHTML = `<a id="footer-upload-link" href="#">åŠ è½½/æ›´æ¢é¢˜åº“</a>`;
                         const footerLink = document.getElementById('footer-upload-link');
                         if (footerLink) {
                            footerLink.onclick = (e) => {
                                e.preventDefault();
                                document.getElementById('csv-upload-input').click();
                            };
                         }
                    } else {
                        footerTriggerContainer.innerHTML = `<a id="footer-initial-upload-link" href="#">ç‚¹æ­¤åŠ è½½é¢˜åº“</a>`;
                        const footerInitialLink = document.getElementById('footer-initial-upload-link');
                        if(footerInitialLink) {
                             footerInitialLink.onclick = (e) => {
                                e.preventDefault();
                                document.getElementById('csv-upload-input').click();
                             };
                        }
                    }
                }
            }

            saveProgress() {
                if (!this.currentFileHash) return; 

                const progressData = {
                    userAnswers: this.userAnswers,
                    activeFilters: this.activeFilters, // Save active filters
                    timestamp: Date.now()
                };
                localStorage.setItem(this.LOCAL_STORAGE_KEY_PREFIX + this.currentFileHash, JSON.stringify(progressData));
            }

            loadProgress() {
                if (!this.currentFileHash) {
                    this.userAnswers = {};
                    this.activeFilters = [];
                    return;
                }
                const savedData = localStorage.getItem(this.LOCAL_STORAGE_KEY_PREFIX + this.currentFileHash);
                if (savedData) {
                    try {
                        const progressData = JSON.parse(savedData);
                        const currentQuestionIds = new Set(this.questions.map(q => String(q.id))); // Ensure IDs are strings
                        const loadedUserAnswers = progressData.userAnswers || {};
                        this.userAnswers = {};
                        for (const qid in loadedUserAnswers) {
                            if (currentQuestionIds.has(String(qid))) { // Compare as strings
                                this.userAnswers[qid] = loadedUserAnswers[qid];
                            }
                        }
                        this.activeFilters = progressData.activeFilters || [];
                        this.updateFilterTags();
                    } catch (error) {
                        console.error('åŠ è½½è¿›åº¦æ•°æ®å¤±è´¥:', error);
                        this.userAnswers = {};
                        this.activeFilters = [];
                    }
                } else {
                     this.userAnswers = {};
                     this.activeFilters = [];
                }
            }
        } 

        // æ”¹è¿›çš„CSVè§£æå‡½æ•°
        function parseCSVLine(line) {
            const result = [];
            let currentField = '';
            let inQuotes = false;
            
            // æ·»åŠ ç©ºè¡Œæ£€æŸ¥
            if (!line || line.trim() === '') {
                return [];
            }
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    if (inQuotes && i + 1 < line.length && line[i + 1] === '"') {
                        currentField += '"';
                        i++;
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    result.push(currentField.trim());
                    currentField = '';
                } else {
                    currentField += char;
                }
            }
            result.push(currentField.trim());
            return result;
        }

        // æ”¹è¿›çš„é€‰é¡¹æå–å‡½æ•°
        function extractOptionsFromStem(fullStem, questionTypeLabel) {
            let questionText = fullStem;
            const options = [];

            if (questionTypeLabel === 'E') { // Judge questions have fixed options
                return { stem: questionText, options: [{ key: "A", text: "æ­£ç¡®" }, { key: "B", text: "é”™è¯¯" }] };
            }

            // å¤„ç†å¤šç§æ¢è¡Œç¬¦æ ¼å¼
            fullStem = String(fullStem || '')
                .replace(/\\r\\n|\\r|\\n/g, '\n')  // å¤„ç†è½¬ä¹‰çš„æ¢è¡Œç¬¦
                .replace(/\r\n/g, '\n')           // å¤„ç†Windowsæ¢è¡Œç¬¦
                .replace(/\r/g, '\n');            // å¤„ç†Macæ¢è¡Œç¬¦
            
            const lines = fullStem.split('\n');
            let stemLines = [];
            let optionStartIndex = -1;
            
            // å¯»æ‰¾ç¬¬ä¸€ä¸ªé€‰é¡¹çš„ä½ç½®
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                const optionMatch = line.match(/^([A-G])\.\s*(.*)$/);
                
                if (optionMatch && optionStartIndex === -1) {
                    optionStartIndex = i;
                    break;
                }
            }
            
            if (optionStartIndex !== -1) {
                // åˆ†ç¦»é¢˜å¹²å’Œé€‰é¡¹
                stemLines = lines.slice(0, optionStartIndex);
                questionText = stemLines.join('\n').trim();
                
                // æå–é€‰é¡¹
                for (let i = optionStartIndex; i < lines.length; i++) {
                    const line = lines[i].trim();
                    const optionMatch = line.match(/^([A-G])\.\s*(.*)$/);
                    
                    if (optionMatch) {
                        options.push({
                            key: optionMatch[1],
                            text: optionMatch[2].trim()
                        });
                    } else if (line && options.length > 0) {
                        // å¦‚æœä¸æ˜¯æ–°é€‰é¡¹ä½†æœ‰å†…å®¹ï¼Œå¯èƒ½æ˜¯ä¸Šä¸€ä¸ªé€‰é¡¹çš„ç»­è¡Œ
                        const lastOption = options[options.length - 1];
                        lastOption.text += ' ' + line;
                    }
                }
            } else {
                // å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ ‡å‡†æ ¼å¼çš„é€‰é¡¹ï¼Œå°è¯•å…¶ä»–è§£ææ–¹æ³•
                const inlineOptionRegex = /([A-G])\.\s*([^A-G]*?)(?=\s*[A-G]\.|$)/g;
                let match;
                let hasInlineOptions = false;
                
                while ((match = inlineOptionRegex.exec(fullStem)) !== null) {
                    if (!hasInlineOptions) {
                        // ç¬¬ä¸€æ¬¡æ‰¾åˆ°é€‰é¡¹ï¼Œåˆ†ç¦»é¢˜å¹²
                        questionText = fullStem.substring(0, match.index).trim();
                        hasInlineOptions = true;
                    }
                    
                    options.push({
                        key: match[1],
                        text: match[2].trim()
                    });
                }
                
                if (!hasInlineOptions) {
                    // å®Œå…¨æ²¡æœ‰æ‰¾åˆ°é€‰é¡¹ï¼Œæ•´ä¸ªä½œä¸ºé¢˜å¹²
                    questionText = fullStem.trim();
                }
            }
            
            // éªŒè¯é€‰é¡¹å®Œæ•´æ€§
            if (options.length === 0 && (questionTypeLabel.startsWith('A') || questionTypeLabel === 'X')) {
                console.warn(`No options extracted for ${questionTypeLabel}. Stem: "${fullStem.substring(0,100)}..."`);
            }

            return { stem: questionText, options: options };
        }

        // åˆ†ç¦»é¢˜ç›®è¡Œè§£æé€»è¾‘
        function parseQuestionRow(row, lineNumber) {
            try {
                const questionTypeLabel = row['é¢˜å‹æ ‡ç­¾'];
                let questionType, options, correctAnswer;
                const rawQuestionText = row['é¢˜å¹²'];
                
                if (!rawQuestionText) {
                    console.warn(`ç¬¬${lineNumber+1}è¡Œé¢˜å¹²ä¸ºç©º`);
                    return null;
                }
                
                // æ ¹æ®é¢˜å‹æ ‡ç­¾è§£æ
                if (questionTypeLabel === 'E') {
                    questionType = 'judge';
                    const optionParseResult = extractOptionsFromStem(rawQuestionText, questionTypeLabel);
                    options = optionParseResult.options;
                    correctAnswer = String(row['ç­”æ¡ˆ']).toUpperCase();
                } else if (['A1', 'A2', 'A3', 'A4', 'A3/A4'].includes(questionTypeLabel)) {
                    questionType = 'single';
                    const optionParseResult = extractOptionsFromStem(rawQuestionText, questionTypeLabel);
                    options = optionParseResult.options;
                    correctAnswer = String(row['ç­”æ¡ˆ']).toUpperCase();
                } else if (questionTypeLabel === 'X') {
                    questionType = 'multiple';
                    const optionParseResult = extractOptionsFromStem(rawQuestionText, questionTypeLabel);
                    options = optionParseResult.options;
                    correctAnswer = row['ç­”æ¡ˆ'] ? String(row['ç­”æ¡ˆ']).toUpperCase().split('').sort() : [];
                } else {
                    console.warn(`æœªçŸ¥é¢˜å‹æ ‡ç­¾: ${questionTypeLabel}, ç¬¬${lineNumber+1}è¡Œ`);
                    return null;
                }

                // éªŒè¯é€‰é¡¹
                if (options.length === 0 && (questionTypeLabel.startsWith('A') || questionTypeLabel === 'X')) {
                    console.warn(`ç¬¬${lineNumber+1}è¡Œæœªèƒ½è§£æå‡ºé€‰é¡¹`);
                }

                const tags = [row['çŸ¥è¯†æ ‘1'], row['çŸ¥è¯†æ ‘2'], row['çŸ¥è¯†æ ‘3'], row['çŸ¥è¯†æ ‘4'], row['çŸ¥è¯†æ ‘5']].filter(Boolean);

                return {
                    id: row['åŸå§‹é¢˜å·'] || `gen_id_${lineNumber}`,
                    subject: row['çŸ¥è¯†æ ‘1'] || 'ç»¼åˆ',
                    type: questionType,
                    question: extractOptionsFromStem(rawQuestionText, questionTypeLabel).stem,
                    options: options,
                    correctAnswer: correctAnswer,
                    explanation: row['è§£æ'] ? String(row['è§£æ']).replace(/\\n/g, '\n') : "æš‚æ— è§£æ",
                    tags: tags,
                    originalData: { ...row, é¢˜å‹æ ‡ç­¾: questionTypeLabel }
                };
                
            } catch (error) {
                console.error(`è§£æç¬¬${lineNumber+1}è¡Œé¢˜ç›®æ—¶å‡ºé”™:`, error);
                return null;
            }
        }

        // éªŒè¯å’Œä¿®å¤é¢˜ç›®æ•°æ®
        function validateAndFixQuestionData(questions) {
            const fixedQuestions = [];
            
            questions.forEach((question, index) => {
                if (!question) return;
                
                // ä¿®å¤ç¼ºå¤±çš„é€‰é¡¹
                if (question.type !== 'judge' && question.options.length === 0) {
                    console.warn(`é¢˜ç›® ${question.id} ç¼ºå°‘é€‰é¡¹ï¼Œå°è¯•ä»é¢˜å¹²é‡æ–°è§£æ`);
                    const reParseResult = extractOptionsFromStem(question.originalData['é¢˜å¹²'], question.originalData['é¢˜å‹æ ‡ç­¾']);
                    if (reParseResult.options.length > 0) {
                        question.options = reParseResult.options;
                        question.question = reParseResult.stem;
                        console.log(`é¢˜ç›® ${question.id} é€‰é¡¹ä¿®å¤æˆåŠŸ`);
                    }
                }
                
                // éªŒè¯ç­”æ¡ˆæœ‰æ•ˆæ€§
                if (question.type === 'single' || question.type === 'judge') {
                    if (!question.correctAnswer || typeof question.correctAnswer !== 'string') {
                        console.warn(`é¢˜ç›® ${question.id} ç­”æ¡ˆæ ¼å¼é”™è¯¯`);
                        return;
                    }
                } else if (question.type === 'multiple') {
                    if (!Array.isArray(question.correctAnswer) || question.correctAnswer.length === 0) {
                        console.warn(`é¢˜ç›® ${question.id} å¤šé€‰é¢˜ç­”æ¡ˆæ ¼å¼é”™è¯¯`);
                        return;
                    }
                }
                
                fixedQuestions.push(question);
            });
            
            return fixedQuestions;
        }

        // æ”¹è¿›çš„CSVè§£æä¸»å‡½æ•°
        function parseCSV(csvText) {
            try {
                // æ·»åŠ æ–‡ä»¶å†…å®¹éªŒè¯
                if (!csvText || typeof csvText !== 'string') {
                    throw new Error('CSVå†…å®¹ä¸ºç©ºæˆ–æ ¼å¼æ— æ•ˆ');
                }
                
                // å¤„ç†ä¸åŒçš„æ¢è¡Œç¬¦
                const lines = csvText.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
                
                if (lines.length < 2) {
                    throw new Error("CSVæ–‡ä»¶è‡³å°‘éœ€è¦åŒ…å«è¡¨å¤´å’Œä¸€è¡Œæ•°æ®");
                }

                const headerLine = lines[0].trim();
                if (!headerLine) {
                    throw new Error("CSVè¡¨å¤´ä¸ºç©º");
                }
                
                const header = parseCSVLine(headerLine);
                
                // éªŒè¯å¿…éœ€çš„åˆ—
                const requiredHeaders = ['é¢˜å‹æ ‡ç­¾', 'åŸå§‹é¢˜å·', 'é¢˜å¹²', 'ç­”æ¡ˆ', 'è§£æ', 'çŸ¥è¯†æ ‘1'];
                const missingHeaders = requiredHeaders.filter(reqHeader => !header.includes(reqHeader));
                
                if (missingHeaders.length > 0) {
                    throw new Error(`CSVæ–‡ä»¶ç¼ºå¤±å¿…éœ€åˆ—: ${missingHeaders.join(', ')}`);
                }

                const questions = [];
                let successCount = 0;
                let errorCount = 0;
                
                for (let i = 1; i < lines.length; i++) {
                    try {
                        const line = lines[i];
                        if (!line || line.trim() === '') continue;

                        const rawFields = parseCSVLine(line);
                        if (rawFields.length === 0 || rawFields.every(f => f === '')) continue;

                        // è¡¥é½ç¼ºå¤±çš„å­—æ®µ
                        while(rawFields.length < header.length) {
                            rawFields.push('');
                        }
                        
                        const row = {};
                        header.forEach((colName, index) => {
                            row[colName] = rawFields[index] || '';
                        });

                        // éªŒè¯å…³é”®å­—æ®µ
                        if (!row['é¢˜å‹æ ‡ç­¾'] || !row['åŸå§‹é¢˜å·'] || !row['é¢˜å¹²']) {
                            console.warn(`ç¬¬${i+1}è¡Œæ•°æ®ä¸å®Œæ•´ï¼Œè·³è¿‡: é¢˜å‹æ ‡ç­¾="${row['é¢˜å‹æ ‡ç­¾']}", åŸå§‹é¢˜å·="${row['åŸå§‹é¢˜å·']}", é¢˜å¹²="${row['é¢˜å¹²']?.substring(0,50)}..."`);
                            errorCount++;
                            continue;
                        }

                        const question = parseQuestionRow(row, i);
                        if (question) {
                            questions.push(question);
                            successCount++;
                        } else {
                            errorCount++;
                        }
                        
                    } catch (rowError) {
                        console.error(`è§£æç¬¬${i+1}è¡Œæ—¶å‡ºé”™:`, rowError);
                        errorCount++;
                    }
                }
                
                // éªŒè¯å’Œä¿®å¤æ•°æ®
                const validatedQuestions = validateAndFixQuestionData(questions);
                
                console.log(`CSVè§£æå®Œæˆ: æˆåŠŸ${validatedQuestions.length}é¢˜, é”™è¯¯${errorCount}é¢˜`);
                
                if (validatedQuestions.length === 0) {
                    throw new Error('æœªèƒ½è§£æå‡ºä»»ä½•æœ‰æ•ˆé¢˜ç›®');
                }
                
                return validatedQuestions;
                
            } catch (error) {
                console.error('CSVè§£æå¤±è´¥:', error);
                throw error;
            }
        }

        // ç”Ÿæˆæ–‡ä»¶å“ˆå¸Œ
        async function generateFileHash(fileContent) {
            try {
                const encoder = new TextEncoder();
                const buffer = encoder.encode(fileContent);
                const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                return hashHex.substring(0, 16); // Shortened hash
            } catch (error) {
                console.error('ç”Ÿæˆæ–‡ä»¶å“ˆå¸Œå¤±è´¥:', error);
                return Date.now().toString(); // Fallback to timestamp
            }
        }

        // æ˜¾ç¤ºé”™è¯¯æç¤ºå‡½æ•°
        function showErrorPrompt(errorMessage) {
            document.getElementById('question-container').innerHTML = `
                <div class="error-prompt">
                    <i class="fas fa-exclamation-triangle fa-3x text-red-400 mb-4"></i>
                    <h3>é¢˜åº“åŠ è½½å¤±è´¥</h3>
                    <p class="text-red-500 mb-4">${errorMessage}</p>
                    <div class="error-details">
                        <p><strong>è¯·æ£€æŸ¥ï¼š</strong></p>
                        <ul>
                            <li>æ–‡ä»¶æ˜¯å¦ä¸ºCSVæ ¼å¼</li>
                            <li>æ–‡ä»¶ç¼–ç æ˜¯å¦ä¸ºUTF-8</li>
                            <li>æ˜¯å¦åŒ…å«å¿…éœ€çš„åˆ—ï¼šé¢˜å‹æ ‡ç­¾ã€åŸå§‹é¢˜å·ã€é¢˜å¹²ã€ç­”æ¡ˆã€è§£æã€çŸ¥è¯†æ ‘1</li>
                            <li>æ•°æ®æ ¼å¼æ˜¯å¦æ­£ç¡®</li>
                            <li>æ–‡ä»¶æ˜¯å¦æŸå</li>
                        </ul>
                    </div>
                    <p class="text-blue-600 cursor-pointer hover:underline" onclick="document.getElementById('csv-upload-input').click()">
                        <i class="fas fa-upload"></i> ç‚¹å‡»æ­¤å¤„é‡æ–°ä¸Šä¼ 
                    </p>
                </div>`;
        }

        // DOMContentLoaded å’Œä¸Šä¼ å¤„ç†
        document.addEventListener('DOMContentLoaded', function() {
            console.log('é¡µé¢å¼€å§‹åŠ è½½...');
            
            const loadingIndicator = document.getElementById('loading-indicator');
            const mainContentWrapper = document.getElementById('main-content-wrapper');
            const csvUploadInput = document.getElementById('csv-upload-input');
            const uploadStatusDisplay = document.getElementById('upload-status-main');

            // ç¡®ä¿åŠ è½½æŒ‡ç¤ºå™¨è¢«æ­£ç¡®éšè—
            if (loadingIndicator) {
                loadingIndicator.style.display = 'none';
                loadingIndicator.style.visibility = 'hidden';
                loadingIndicator.style.opacity = '0';
            }
            
            if (mainContentWrapper) {
                mainContentWrapper.style.visibility = 'visible';
                mainContentWrapper.classList.remove('hidden-initial');
            }
            
            console.log('åˆå§‹åŒ–é¢˜åº“ç³»ç»Ÿ...');
            window.quizSystem = new QuizSystem(); // Initialize quiz system instance

            // å°è¯•ä»æœ¬åœ°å­˜å‚¨åŠ è½½é¢˜åº“
            const storedQs = localStorage.getItem(STORED_QUESTIONS_KEY);
            const storedHash = localStorage.getItem(STORED_FILE_HASH_KEY);
            
            if (storedQs && storedHash) {
                try {
                    console.log('å‘ç°æœ¬åœ°ç¼“å­˜çš„é¢˜åº“ï¼Œæ­£åœ¨åŠ è½½...');
                    const parsedQs = JSON.parse(storedQs);
                    if (parsedQs && parsedQs.length > 0) {
                        questionsData = parsedQs;
                        window.quizSystem.initializeQuiz(questionsData, storedHash, true);
                        uploadStatusDisplay.textContent = `å·²ä»ç¼“å­˜åŠ è½½ ${questionsData.length} é“é¢˜ç›®ã€‚`;
                        uploadStatusDisplay.className = 'text-blue-500 text-center mb-4';
                    } else {
                        console.log('ç¼“å­˜çš„é¢˜åº“ä¸ºç©ºï¼Œæ˜¾ç¤ºåˆå§‹æç¤º');
                        window.quizSystem.renderInitialPrompt();
                    }
                } catch (e) {
                    console.error("è§£æå­˜å‚¨çš„é¢˜åº“æ•°æ®å¤±è´¥:", e);
                    localStorage.removeItem(STORED_QUESTIONS_KEY);
                    localStorage.removeItem(STORED_FILE_HASH_KEY);
                    window.quizSystem.renderInitialPrompt();
                }
            } else {
                console.log('æ²¡æœ‰æ‰¾åˆ°ç¼“å­˜çš„é¢˜åº“ï¼Œæ˜¾ç¤ºåˆå§‹æç¤º');
                window.quizSystem.renderInitialPrompt();
            }

            // æ”¹è¿›çš„æ–‡ä»¶ä¸Šä¼ å¤„ç†
            if (csvUploadInput) {
                csvUploadInput.addEventListener('change', async function(event) {
                    const file = event.target.files[0];
                    if (!file) return;
                    
                    console.log('å¼€å§‹å¤„ç†ä¸Šä¼ çš„æ–‡ä»¶:', file.name, 'å¤§å°:', file.size);
                    
                    // éªŒè¯æ–‡ä»¶ç±»å‹
                    if (!file.name.toLowerCase().endsWith('.csv')) {
                        uploadStatusDisplay.textContent = 'è¯·é€‰æ‹©CSVæ ¼å¼çš„æ–‡ä»¶ï¼';
                        uploadStatusDisplay.className = 'text-red-500 text-center mb-4';
                        event.target.value = null;
                        return;
                    }
                    
                    // éªŒè¯æ–‡ä»¶å¤§å° (ä¾‹å¦‚é™åˆ¶10MB)
                    if (file.size > 10 * 1024 * 1024) {
                        uploadStatusDisplay.textContent = 'æ–‡ä»¶è¿‡å¤§ï¼Œè¯·é€‰æ‹©å°äº10MBçš„æ–‡ä»¶ï¼';
                        uploadStatusDisplay.className = 'text-red-500 text-center mb-4';
                        event.target.value = null;
                        return;
                    }
                    
                    uploadStatusDisplay.textContent = 'æ­£åœ¨è¯»å–æ–‡ä»¶...';
                    uploadStatusDisplay.className = 'text-blue-500 text-center mb-4';
                    
                    const reader = new FileReader();
                    
                    reader.onload = async function(e) {
                        try {
                            uploadStatusDisplay.textContent = 'æ­£åœ¨è§£æé¢˜åº“...';
                            
                            const fileContent = e.target.result;
                            
                            // æ£€æµ‹æ–‡ä»¶ç¼–ç é—®é¢˜
                            if (fileContent.includes('ï¿½')) {
                                uploadStatusDisplay.textContent = 'æ–‡ä»¶ç¼–ç å¯èƒ½æœ‰é—®é¢˜ï¼Œè¯·ç¡®ä¿ä½¿ç”¨UTF-8ç¼–ç ä¿å­˜CSVæ–‡ä»¶ï¼';
                                uploadStatusDisplay.className = 'text-orange-500 text-center mb-4';
                                console.warn('æ£€æµ‹åˆ°æ–‡ä»¶ç¼–ç é—®é¢˜');
                            }
                            
                            const fileHash = await generateFileHash(fileContent);
                            console.log('æ–‡ä»¶å“ˆå¸Œ:', fileHash);

                            // æ£€æŸ¥æ˜¯å¦å·²åŠ è½½ç›¸åŒæ–‡ä»¶
                            if (window.quizSystem.currentFileHash === fileHash && window.quizSystem.questions.length > 0) {
                                if (!confirm('è¿™ä¸ªé¢˜åº“æ–‡ä»¶ä¼¼ä¹å·²ç»åŠ è½½è¿‡äº†ã€‚æ˜¯å¦è¦é‡æ–°åŠ è½½å¹¶å¯èƒ½ä¸¢å¤±å½“å‰è¿›åº¦ï¼Ÿ')) {
                                    uploadStatusDisplay.textContent = 'æ“ä½œå·²å–æ¶ˆã€‚';
                                    uploadStatusDisplay.className = 'text-gray-500 text-center mb-4';
                                    event.target.value = null;
                                    return;
                                }
                            }

                            console.log('å¼€å§‹è§£æCSVå†…å®¹...');
                            questionsData = parseCSV(fileContent);
                            
                            if (questionsData.length > 0) {
                                console.log(`æˆåŠŸè§£æ ${questionsData.length} é“é¢˜ç›®`);
                                window.quizSystem.initializeQuiz(questionsData, fileHash, false);
                            } else {
                                throw new Error('æœªèƒ½è§£æå‡ºä»»ä½•é¢˜ç›®');
                            }
                            
                        } catch (parseError) {
                            console.error("CSVè§£æé”™è¯¯:", parseError);
                            uploadStatusDisplay.textContent = `è§£æå¤±è´¥: ${parseError.message}`;
                            uploadStatusDisplay.className = 'text-red-500 text-center mb-4';
                            
                            // æ˜¾ç¤ºå‹å¥½çš„é”™è¯¯æç¤º
                            showErrorPrompt(parseError.message);
                        }
                    };
                    
                    reader.onerror = function() {
                        console.error('æ–‡ä»¶è¯»å–å¤±è´¥');
                        uploadStatusDisplay.textContent = 'è¯»å–æ–‡ä»¶å¤±è´¥ï¼è¯·æ£€æŸ¥æ–‡ä»¶æ˜¯å¦æŸåã€‚';
                        uploadStatusDisplay.className = 'text-red-500 text-center mb-4';
                    };
                    
                    // è®¾ç½®è¶…æ—¶
                    const timeoutId = setTimeout(() => {
                        if (uploadStatusDisplay.textContent.includes('æ­£åœ¨')) {
                            console.warn('æ–‡ä»¶å¤„ç†è¶…æ—¶');
                            uploadStatusDisplay.textContent = 'æ–‡ä»¶å¤„ç†è¶…æ—¶ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶å¤§å°å’Œå†…å®¹ï¼';
                            uploadStatusDisplay.className = 'text-red-500 text-center mb-4';
                        }
                    }, 30000); // 30ç§’è¶…æ—¶
                    
                    reader.readAsText(file, 'UTF-8');
                    event.target.value = null; // Reset file input to allow re-uploading the same file
                    
                    // æ¸…é™¤è¶…æ—¶
                    reader.addEventListener('loadend', () => {
                        clearTimeout(timeoutId);
                    });
                });
            }
            
            console.log('é¡µé¢åˆå§‹åŒ–å®Œæˆ');
        });
    </script>
</body>
</html>
